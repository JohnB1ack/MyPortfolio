<!DOCTYPE HTML>
<html>
<head>
<title>John C. Black - Analyst & Developer</title>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />

<!-- Google Fonts & Font Awesome -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
:root {
--color-background: #0D1117;
--color-text-main: #E6EDF3;
--color-text-secondary: #8B949E;
--color-border: rgba(255, 255, 255, 0.1);
--font-main: 'Inter', sans-serif;
--glow-analyst: rgba(88, 166, 255, 0.2);
--glow-developer: rgba(67, 233, 123, 0.2);
}

*, *::before, *::after {
box-sizing: border-box;
margin: 0;
padding: 0;
}

body {
background-color: var(--color-background);
font-family: var(--font-main);
color: var(--color-text-main);
overflow-x: hidden;
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;
-webkit-text-size-adjust: 100%;
-ms-text-size-adjust: 100%;
}

#canvas-background {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
z-index: 1;
background-color: var(--color-background);
background-image:
radial-gradient(ellipse at 15% 80%, var(--glow-analyst), transparent 50%),
radial-gradient(ellipse at 85% 80%, var(--glow-developer), transparent 50%);
}

#wrapper {
position: relative;
z-index: 2;
width: 100%;
min-height: 100vh;
display: flex;
flex-direction: column;
align-items: center;
padding: 2rem;
}

/* Main hero layout */
#mindset-container {
display: flex;
justify-content: center;
align-items: flex-start;
width: 100%;
max-width: 1400px;
min-height: 70vh;
padding-top: 5vh;
}

.mindset-side {
flex: 1;
padding: 2rem;
height: 60vh;
position: relative;
}

.mindset-side h2 {
font-size: clamp(1.5rem, 4vw, 2rem);
font-weight: 700;
color: var(--color-text-secondary);
text-align: center;
margin-bottom: 2rem;
position: relative;
z-index: 3;
}

#analyst-side h2 { text-align: right; }
#developer-side h2 { text-align: left; }

.skills-cloud {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
}

.skill-node {
position: absolute;
font-size: clamp(0.8rem, 1.5vw, 1rem);
font-weight: 500;
padding: 8px 16px;
background-color: rgba(13, 17, 23, 0.6);
border: 1px solid var(--color-border);
border-radius: 20px;
backdrop-filter: blur(8px);
-webkit-backdrop-filter: blur(8px);
color: var(--color-text-secondary);
white-space: nowrap;
transform: translate(-50%, -50%);
transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
z-index: 2;
cursor: pointer;
-webkit-tap-highlight-color: transparent;
user-select: none;
-webkit-user-select: none;
}

.skill-node:hover {
border-color: var(--glow-analyst);
background-color: rgba(13, 17, 23, 0.8);
transform: translate(-50%, -50%) scale(1.05);
box-shadow: 0 0 20px rgba(88, 166, 255, 0.3);
}

.skill-node:active {
transform: translate(-50%, -50%) scale(0.95);
}

.skill-node.constellation-active {
border-color: #58a6ff;
background-color: rgba(88, 166, 255, 0.15);
color: #58a6ff;
text-shadow: 0 0 15px rgba(88, 166, 255, 0.8);
box-shadow:
    0 0 30px rgba(88, 166, 255, 0.5),
    inset 0 0 20px rgba(88, 166, 255, 0.1);
animation: constellation-pulse 2s ease-in-out infinite;
}

@keyframes constellation-pulse {
0%, 100% {
    box-shadow:
        0 0 30px rgba(88, 166, 255, 0.5),
        inset 0 0 20px rgba(88, 166, 255, 0.1);
}
50% {
    box-shadow:
        0 0 40px rgba(88, 166, 255, 0.8),
        inset 0 0 25px rgba(88, 166, 255, 0.2);
}
}

.skill-node.active {
color: var(--color-text-main);
text-shadow: 0 0 10px currentColor;
}

#analyst-side .skill-node.active { color: #80bfff; }
#developer-side .skill-node.active { color: #72f7b1; }

#profile-center {
flex: 0 0 auto;
width: 300px;
text-align: center;
padding: 2rem 1rem;
margin-top: 4rem;
position: relative;
z-index: 10;
}

#profile-center h1 {
font-size: clamp(2rem, 5vw, 3rem);
font-weight: 700;
color: var(--color-text-main);
margin-bottom: 1rem;
text-align: center;
}

#profile-center p {
font-size: 1.1rem;
line-height: 1.7;
color: var(--color-text-secondary);
max-width: 500px;
margin: 0 auto;
text-align: center;
}

/* Project Cards Section */
#project-grid {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
gap: 2rem;
width: 100%;
max-width: 1200px;
padding: 5rem 0;
}

.project-card {
background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02));
border: 1px solid var(--color-border);
border-radius: 16px;
padding: 2.5rem;
text-decoration: none;
color: inherit;
position: relative;
overflow: hidden;
transition: all 0.4s ease;
backdrop-filter: blur(12px);
-webkit-backdrop-filter: blur(12px);
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
-webkit-tap-highlight-color: rgba(88, 166, 255, 0.1);
touch-action: manipulation;
cursor: pointer;
}

.project-card::before {
content: '';
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), transparent);
opacity: 0;
transition: opacity 0.3s ease;
pointer-events: none;
}

.project-card:hover {
transform: translateY(-10px);
border-color: rgba(255, 255, 255, 0.3);
box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2), 0 0 20px rgba(255, 255, 255, 0.1);
}

.project-card:hover::before {
opacity: 1;
}

.project-card.active {
border-color: rgba(88, 166, 255, 0.4);
box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2), 0 0 30px rgba(88, 166, 255, 0.2);
}

.project-card.active::before {
background: linear-gradient(135deg, rgba(88, 166, 255, 0.1), rgba(67, 233, 123, 0.05));
opacity: 1;
}

.project-card.active .card-icon {
color: #58A6FF;
text-shadow: 0 0 15px rgba(88, 166, 255, 0.5);
transform: scale(1.1);
transition: all 0.3s ease;
}

.project-card.active .card-title {
color: #58A6FF;
text-shadow: 0 0 10px rgba(88, 166, 255, 0.3);
}

.card-icon {
font-size: 2.5rem;
margin-bottom: 1.5rem;
color: #58A6FF;
transition: all 0.3s ease;
}

.card-title {
font-size: 1.25rem;
font-weight: 700;
color: var(--color-text-main);
margin-bottom: 0.75rem;
transition: all 0.3s ease;
}

.card-description {
font-size: 0.95rem;
color: var(--color-text-secondary);
line-height: 1.7;
}

/* Message Card Special Styling */
.message-card {
background: linear-gradient(135deg, rgba(88, 166, 255, 0.1), rgba(67, 233, 123, 0.1)) !important;
border: 2px solid rgba(88, 166, 255, 0.3) !important;
position: relative;
overflow: hidden;
}

.message-card::before {
content: '';
position: absolute;
top: 0;
left: -100%;
width: 100%;
height: 100%;
background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
transition: left 0.5s ease;
}

.message-card:hover::before {
left: 100%;
}

.message-card:hover {
transform: translateY(-8px) !important;
box-shadow: 0 15px 40px rgba(88, 166, 255, 0.3) !important;
border-color: rgba(88, 166, 255, 0.6) !important;
}

.message-card .card-icon {
color: var(--glow-analyst) !important;
font-size: 3rem !important;
}

.message-card .card-title {
background: linear-gradient(135deg, var(--glow-analyst), var(--glow-developer));
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
}

.message-card .card-description {
color: var(--color-text-main) !important;
font-weight: 500;
}

.message-card.active {
border-color: rgba(67, 233, 123, 0.6) !important;
box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2), 0 0 40px rgba(67, 233, 123, 0.3) !important;
}

.message-card.active .card-icon {
color: #43E97B !important;
text-shadow: 0 0 20px rgba(67, 233, 123, 0.6) !important;
}

.message-card.active .card-title {
background: linear-gradient(135deg, #43E97B, #58A6FF) !important;
-webkit-background-clip: text !important;
-webkit-text-fill-color: transparent !important;
background-clip: text !important;
}

/* Responsive adjustments */
@media (max-width: 1024px) {
#mindset-container {
flex-direction: column;
align-items: center;
min-height: unset;
padding-top: 2rem;
}

.mindset-side {
width: 100%;
max-width: 600px;
height: 40vh;
padding: 1rem;
}

#analyst-side { order: 2; }
#profile-center { order: 1; margin-top: 0; }
#developer-side { order: 3; }
#analyst-side h2, #developer-side h2 { text-align: center; }
}

@media (max-width: 768px) {
#wrapper {
padding: 1rem;
}

#mindset-container {
padding-top: 1rem;
}

.mindset-side {
height: 30vh;
padding: 0.5rem;
}

#profile-center {
margin-top: 2rem;
margin-bottom: 2rem;
}

#project-grid {
padding: 2rem 0;
gap: 1.5rem;
grid-template-columns: 1fr;
}

.project-card {
padding: 2rem;
margin: 0 auto;
max-width: 400px;
}

.card-icon {
font-size: 2rem;
margin-bottom: 1rem;
}

.card-title {
font-size: 1.1rem;
}

.card-description {
font-size: 0.9rem;
}
}

@media (max-width: 480px) {
#wrapper {
padding: 0.5rem;
}

.mindset-side {
height: 25vh;
padding: 0.25rem;
}

.skill-node {
font-size: 0.7rem;
padding: 6px 12px;
}

#profile-center h1 {
font-size: 1.8rem;
}

#profile-center p {
font-size: 0.85rem;
padding: 0 1rem;
}

#project-grid {
gap: 1rem;
padding: 1.5rem 0;
}

.project-card {
padding: 1.5rem;
border-radius: 12px;
}

.card-icon {
font-size: 1.8rem;
}

.card-title {
font-size: 1rem;
}

.card-description {
font-size: 0.85rem;
line-height: 1.5;
}
}

@media (max-width: 360px) {
.mindset-side {
height: 20vh;
}

.skill-node {
font-size: 0.6rem;
padding: 4px 8px;
}

#profile-center h1 {
font-size: 1.6rem;
}

.project-card {
padding: 1.25rem;
}
}

/* Mobile-specific enhancements */
@media (hover: none) and (pointer: coarse) {
.project-card:active {
transform: translateY(-5px) scale(0.98);
border-color: rgba(88, 166, 255, 0.5);
}

.skill-node {
pointer-events: none;
}
}

/* Reduce motion for users who prefer it */
@media (prefers-reduced-motion: reduce) {
.project-card,
.skill-node,
.card-icon,
.card-title {
transition: none;
}
}

/* Hide original theme elements to prevent conflicts */
#main, #header, #nav, #intro { display: none !important; }
#wrapper { display: flex !important; }
</style>
</head>
<body>

<canvas id="canvas-background"></canvas>

<div id="wrapper">
<section id="mindset-container">

<div id="analyst-side" class="mindset-side">
<h2>Futures Brokerage Analyst</h2>
<div id="analyst-skills" class="skills-cloud"></div>
</div>

<div id="profile-center">
<h1>John C. Black</h1>
<p>A builder at the intersection of finance and technology, transforming complex problems into elegant automation solutions.</p>
</div>

<div id="developer-side" class="mindset-side">
<h2>Citizen Developer</h2>
<div id="developer-skills" class="skills-cloud"></div>
</div>

</section>

<section id="project-grid">
<a href="about-me.html" class="project-card user-experience">
<i class="card-icon fas fa-user-astronaut"></i>
<h3 class="card-title">About Me</h3>
<p class="card-description">Learn about my journey from operations to innovation and my approach to solving complex challenges.</p>
</a>

<a href="streamlit-report-generator.html" class="project-card dashboard-development financial-analysis">
<i class="card-icon fas fa-chart-line"></i>
<h3 class="card-title">Reporting Platform</h3>
<p class="card-description">A unified platform serving as a centralized hub for reporting needs across departments.</p>
</a>

<a href="interest-rate-automation.html" class="project-card automation-platform risk-automation">
<i class="card-icon fas fa-cogs"></i>
<h3 class="card-title">Automation Engine</h3>
<p class="card-description">Discover how a custom solution reduced daily processing from 4 hours to 15 minutes.</p>
</a>

<a href="xtp-data-integration.html" class="project-card data-platform system-integration">
<i class="card-icon fas fa-database"></i>
<h3 class="card-title">Data Processing</h3>
<p class="card-description">Enhanced collaboration through Alteryx workflows, empowering teams with direct data access.</p>
</a>

<a href="generic.html" class="project-card ai-development">
<i class="card-icon fas fa-code"></i>
<h3 class="card-title">Foundational Skills</h3>
<p class="card-description">Where it all began: SQL & SAS taught me patience and the mission to make data work for people.</p>
</a>

<a href="https://www.linkedin.com/in/john-black-532677194/" target="_blank" class="project-card message-card">
<i class="card-icon fas fa-envelope"></i>
<h3 class="card-title">Message Me</h3>
<p class="card-description">Ready to discuss automation opportunities? Let's connect and explore how citizen development can transform your processes.</p>
</a>
</section>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {

// --- CONFIGURATION: EDIT YOUR SKILLS AND QUALITIES HERE ---
const analystSkills = [
{ name: 'Financial Reporting', constellationStars: [] },
{ name: 'Risk Management', constellationStars: [] },
{ name: 'Trade Reconciliation', constellationStars: [] },
{ name: 'Data-Driven Analysis', constellationStars: [] },
{ name: 'Futures Settlement', constellationStars: [] },
{ name: 'Operational Efficiency', constellationStars: [] },
{ name: 'Regulatory Compliance', constellationStars: [] },
{ name: 'Financial System Integrity', constellationStars: [] }
];

const developerSkills = [
{ name: 'Python Process Automation', constellationStars: [] },
{ name: 'AI/ML Frameworks', constellationStars: [] },
{ name: 'API Integration', constellationStars: [] },
{ name: 'Data Pipeline Architecture', constellationStars: [] },
{ name: 'Alteryx Development', constellationStars: [] },
{ name: 'System Integration', constellationStars: [] },
{ name: 'Interactive Dashboards', constellationStars: [] },
{ name: 'User Empowerment Focus', constellationStars: [] }
];

// --- SCRIPT LOGIC ---
const canvas = document.getElementById('canvas-background');
const ctx = canvas.getContext('2d');
let mouse = { x: null, y: null };
const allNodes = [];
const projectCards = [];
let animationTime = 0;
let isMobile = false;
let isTouch = false;

// Enhanced star system
let stars = [];
let nebulaClouds = [];
let shootingStars = [];
let mouseTrails = [];
let connectionParticles = [];

// Enhanced visual configuration
const starColors = [
    '#ffffff', '#ffe9c4', '#c4e9ff', '#ffc4c4', '#c4ffc4', '#e9c4ff',
    '#58a6ff', '#67e97b', '#ff6b6b', '#ffd93d', '#6bcf7f', '#c47eff'
];

// Create enhanced star field with various effects
function createEnhancedStarField() {
    stars = [];
    nebulaClouds = [];
    
    // Create main stars with varied properties
    const starCount = isMobile ? 150 : 250;
    for (let i = 0; i < starCount; i++) {
        stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            radius: Math.random() * 2 + 0.5,
            opacity: Math.random() * 0.8 + 0.2,
            twinkleSpeed: Math.random() * 0.02 + 0.01,
            twinklePhase: Math.random() * Math.PI * 2,
            color: starColors[Math.floor(Math.random() * starColors.length)],
            pulseSpeed: Math.random() * 0.5 + 0.5,
            isSpecial: Math.random() < 0.1 // 10% chance for special stars
        });
    }
    
    // Create nebula clouds for depth
    const nebulaCount = isMobile ? 3 : 5;
    for (let i = 0; i < nebulaCount; i++) {
        nebulaClouds.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            radius: Math.random() * 200 + 100,
            color: Math.random() < 0.5 ? 'rgba(88, 166, 255, 0.05)' : 'rgba(67, 233, 123, 0.05)',
            drift: {
                x: (Math.random() - 0.5) * 0.1,
                y: (Math.random() - 0.5) * 0.1
            }
        });
    }
}

// Create shooting star effect
function createShootingStar() {
    if (shootingStars.length < 3 && Math.random() < 0.002) {
        const startX = Math.random() * canvas.width;
        const startY = Math.random() * canvas.height * 0.5;
        const angle = Math.random() * Math.PI / 4 + Math.PI / 6;
        
        shootingStars.push({
            x: startX,
            y: startY,
            length: Math.random() * 100 + 50,
            speed: Math.random() * 5 + 3,
            angle: angle,
            opacity: 1,
            trail: []
        });
    }
}

// Update shooting stars
function updateShootingStars() {
    shootingStars = shootingStars.filter(star => {
        star.x += Math.cos(star.angle) * star.speed;
        star.y += Math.sin(star.angle) * star.speed;
        star.opacity *= 0.98;
        
        // Add to trail
        star.trail.push({ x: star.x, y: star.y, opacity: star.opacity });
        if (star.trail.length > 20) star.trail.shift();
        
        return star.opacity > 0.01 && star.x < canvas.width && star.y < canvas.height;
    });
}

// Create mouse trail particles
function createMouseTrail() {
    if (mouse.x && mouse.y && mouseTrails.length < 30) {
        mouseTrails.push({
            x: mouse.x,
            y: mouse.y,
            vx: (Math.random() - 0.5) * 2,
            vy: (Math.random() - 0.5) * 2,
            radius: Math.random() * 3 + 1,
            opacity: 0.8,
            color: Math.random() < 0.5 ? '#58a6ff' : '#67e97b'
        });
    }
}

// Update mouse trails
function updateMouseTrails() {
    mouseTrails = mouseTrails.filter(trail => {
        trail.x += trail.vx;
        trail.y += trail.vy;
        trail.opacity *= 0.95;
        trail.radius *= 0.98;
        return trail.opacity > 0.01;
    });
}

// Enhanced star rendering with twinkling and special effects
function renderEnhancedStars() {
    // Render nebula clouds first for background effect
    nebulaClouds.forEach(cloud => {
        const gradient = ctx.createRadialGradient(cloud.x, cloud.y, 0, cloud.x, cloud.y, cloud.radius);
        gradient.addColorStop(0, cloud.color);
        gradient.addColorStop(1, 'transparent');
        
        ctx.save();
        ctx.fillStyle = gradient;
        ctx.fillRect(cloud.x - cloud.radius, cloud.y - cloud.radius, cloud.radius * 2, cloud.radius * 2);
        ctx.restore();
        
        // Drift nebula
        cloud.x += cloud.drift.x;
        cloud.y += cloud.drift.y;
        
        // Wrap around screen
        if (cloud.x < -cloud.radius) cloud.x = canvas.width + cloud.radius;
        if (cloud.x > canvas.width + cloud.radius) cloud.x = -cloud.radius;
        if (cloud.y < -cloud.radius) cloud.y = canvas.height + cloud.radius;
        if (cloud.y > canvas.height + cloud.radius) cloud.y = -cloud.radius;
    });
    
    // Render stars with enhanced effects
    stars.forEach(star => {
        const twinkle = Math.sin(animationTime * star.twinkleSpeed + star.twinklePhase) * 0.5 + 0.5;
        const pulse = star.isSpecial ? Math.sin(animationTime * star.pulseSpeed) * 0.3 + 0.7 : 1;
        
        ctx.save();
        ctx.globalAlpha = star.opacity * twinkle * pulse;
        
        // Special stars get extra effects
        if (star.isSpecial) {
            // Outer glow
            const gradient = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, star.radius * 8);
            gradient.addColorStop(0, star.color);
            gradient.addColorStop(0.2, star.color);
            gradient.addColorStop(1, 'transparent');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(star.x - star.radius * 8, star.y - star.radius * 8, star.radius * 16, star.radius * 16);
            
            // Core with enhanced glow
            ctx.shadowBlur = 15;
            ctx.shadowColor = star.color;
        } else {
            ctx.shadowBlur = 5;
            ctx.shadowColor = star.color;
        }
        
        ctx.fillStyle = star.color;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Add cross pattern for bright stars
        if (star.radius > 1.5) {
            ctx.globalAlpha *= 0.5;
            ctx.strokeStyle = star.color;
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(star.x - star.radius * 3, star.y);
            ctx.lineTo(star.x + star.radius * 3, star.y);
            ctx.moveTo(star.x, star.y - star.radius * 3);
            ctx.lineTo(star.x, star.y + star.radius * 3);
            ctx.stroke();
        }
        
        ctx.restore();
    });
    
    // Render shooting stars
    shootingStars.forEach(star => {
        ctx.save();
        
        // Draw trail
        star.trail.forEach((point, index) => {
            if (index < star.trail.length - 1) {
                const nextPoint = star.trail[index + 1];
                const gradient = ctx.createLinearGradient(point.x, point.y, nextPoint.x, nextPoint.y);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${point.opacity * 0.3})`);
                gradient.addColorStop(1, `rgba(255, 255, 255, ${nextPoint.opacity * 0.6})`);
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(point.x, point.y);
                ctx.lineTo(nextPoint.x, nextPoint.y);
                ctx.stroke();
            }
        });
        
        // Draw head
        ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#ffffff';
        ctx.beginPath();
        ctx.arc(star.x, star.y, 2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    });
    
    // Render mouse trails
    mouseTrails.forEach(trail => {
        ctx.save();
        ctx.globalAlpha = trail.opacity;
        ctx.fillStyle = trail.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = trail.color;
        ctx.beginPath();
        ctx.arc(trail.x, trail.y, trail.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    });
}

// Enhanced mouse connection lines with particles and gradients
function renderEnhancedConnections() {
    if (!mouse.x || !mouse.y) return;
    
    const mouseSide = (mouse.x < window.innerWidth / 2) ? 'analyst' : 'developer';
    
    allNodes.forEach(node => {
        const rect = node.element.getBoundingClientRect();
        const nodeCenterX = rect.left + rect.width / 2;
        const nodeCenterY = rect.top + rect.height / 2;
        
        const dist = Math.sqrt(Math.pow(nodeCenterX - mouse.x, 2) + Math.pow(nodeCenterY - mouse.y, 2));
        
        // Handle skill nodes
        if (node.type !== 'project-card') {
            const skillRange = isMobile ? 200 : 400;
            if (node.side === mouseSide && dist < skillRange) {
                node.element.classList.add('active');
                
                // Create gradient for connection line
                const gradient = ctx.createLinearGradient(mouse.x, mouse.y, nodeCenterX, nodeCenterY);
                const baseColor = node.side === 'analyst' ? '88, 166, 255' : '67, 233, 123';
                const opacity = 0.8 * (1 - dist / skillRange);
                
                gradient.addColorStop(0, `rgba(${baseColor}, ${opacity * 0.2})`);
                gradient.addColorStop(0.5, `rgba(${baseColor}, ${opacity})`);
                gradient.addColorStop(1, `rgba(${baseColor}, ${opacity * 0.2})`);
                
                // Draw main connection line with glow
                ctx.save();
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 20;
                ctx.shadowColor = `rgba(${baseColor}, ${opacity})`;
                ctx.beginPath();
                ctx.moveTo(mouse.x, mouse.y);
                ctx.lineTo(nodeCenterX, nodeCenterY);
                ctx.stroke();
                
                // Draw energy pulse along line
                const pulsePos = (animationTime * 3) % 1;
                const pulseX = mouse.x + (nodeCenterX - mouse.x) * pulsePos;
                const pulseY = mouse.y + (nodeCenterY - mouse.y) * pulsePos;
                
                ctx.fillStyle = `rgba(${baseColor}, ${opacity * 1.5})`;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(pulseX, pulseY, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw particles along connection
                for (let i = 0; i < 5; i++) {
                    const particlePos = (pulsePos + i * 0.2) % 1;
                    const px = mouse.x + (nodeCenterX - mouse.x) * particlePos;
                    const py = mouse.y + (nodeCenterY - mouse.y) * particlePos;
                    
                    ctx.fillStyle = `rgba(${baseColor}, ${opacity * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(px, py, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
                
                // Add star burst at node position
                ctx.save();
                ctx.globalAlpha = opacity * 0.3;
                ctx.strokeStyle = `rgb(${baseColor})`;
                ctx.lineWidth = 1;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + animationTime;
                    const x1 = nodeCenterX + Math.cos(angle) * 10;
                    const y1 = nodeCenterY + Math.sin(angle) * 10;
                    const x2 = nodeCenterX + Math.cos(angle) * 20;
                    const y2 = nodeCenterY + Math.sin(angle) * 20;
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
                ctx.restore();
                
            } else {
                node.element.classList.remove('active');
            }
        }
        // Handle project cards with enhanced effects
        else {
            const cardRange = isMobile ? 150 : 300;
            if (dist < cardRange) {
                node.element.classList.add('active');
                
                const baseOpacity = 0.6 * (1 - dist / cardRange);
                const isMessageCard = node.element.classList.contains('message-card');
                
                // Create spiral connection for message card
                if (isMessageCard) {
                    ctx.save();
                    
                    // Draw spiral path
                    ctx.beginPath();
                    const steps = 50;
                    for (let i = 0; i <= steps; i++) {
                        const t = i / steps;
                        const spiral = t * Math.PI * 2;
                        const radius = t * 20;
                        const x = mouse.x + (nodeCenterX - mouse.x) * t + Math.cos(spiral + animationTime * 2) * radius * (1 - t);
                        const y = mouse.y + (nodeCenterY - mouse.y) * t + Math.sin(spiral + animationTime * 2) * radius * (1 - t);
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    
                    const gradient = ctx.createLinearGradient(mouse.x, mouse.y, nodeCenterX, nodeCenterY);
                    gradient.addColorStop(0, `rgba(67, 233, 123, ${baseOpacity * 0.3})`);
                    gradient.addColorStop(0.5, `rgba(88, 166, 255, ${baseOpacity})`);
                    gradient.addColorStop(1, `rgba(67, 233, 123, ${baseOpacity * 0.3})`);
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = 'rgba(67, 233, 123, 0.5)';
                    ctx.stroke();
                    
                    ctx.restore();
                } else {
                    // Regular project cards with wave effect
                    ctx.save();
                    
                    ctx.beginPath();
                    const steps = 30;
                    for (let i = 0; i <= steps; i++) {
                        const t = i / steps;
                        const wave = Math.sin(t * Math.PI * 4 + animationTime * 3) * 10;
                        const perpX = -(nodeCenterY - mouse.y) / dist;
                        const perpY = (nodeCenterX - mouse.x) / dist;
                        
                        const x = mouse.x + (nodeCenterX - mouse.x) * t + perpX * wave * (1 - Math.abs(t - 0.5) * 2);
                        const y = mouse.y + (nodeCenterY - mouse.y) * t + perpY * wave * (1 - Math.abs(t - 0.5) * 2);
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    
                    const gradient = ctx.createLinearGradient(mouse.x, mouse.y, nodeCenterX, nodeCenterY);
                    gradient.addColorStop(0, `rgba(88, 166, 255, ${baseOpacity * 0.2})`);
                    gradient.addColorStop(0.5, `rgba(88, 166, 255, ${baseOpacity})`);
                    gradient.addColorStop(1, `rgba(88, 166, 255, ${baseOpacity * 0.2})`);
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = 'rgba(88, 166, 255, 0.5)';
                    ctx.stroke();
                    
                    ctx.restore();
                }
                
                // Add glow at both ends
                ctx.save();
                ctx.fillStyle = isMessageCard ? 'rgba(67, 233, 123, 0.8)' : 'rgba(88, 166, 255, 0.8)';
                ctx.shadowBlur = 20;
                ctx.shadowColor = ctx.fillStyle;
                ctx.globalAlpha = baseOpacity;
                
                // Mouse end
                ctx.beginPath();
                ctx.arc(mouse.x, mouse.y, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Node end
                ctx.beginPath();
                ctx.arc(nodeCenterX, nodeCenterY, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                
            } else {
                node.element.classList.remove('active');
            }
        }
    });
}

// Skill placement function
function createSkillNodes(containerId, skills) {
    const container = document.getElementById(containerId);
    const nodeArray = [];
    
    let skillsToShow = skills;
    if (window.innerWidth <= 480) {
        skillsToShow = skills.slice(0, 6);
    } else if (window.innerWidth <= 768) {
        skillsToShow = skills.slice(0, 7);
    }
    
    skillsToShow.forEach(skill => {
        const node = document.createElement('div');
        node.className = 'skill-node';
        node.textContent = skill.name;
        
        let x, y, tooClose;
        do {
            tooClose = false;
            x = 10 + Math.random() * 80;
            y = 15 + Math.random() * 70;
            
            for (const existingNode of nodeArray) {
                const dist = Math.sqrt(Math.pow(existingNode.x - x, 2) + Math.pow(existingNode.y - y, 2));
                if (dist < 20) {
                    tooClose = true;
                    break;
                }
            }
        } while (tooClose);
        
        node.style.left = `${x}%`;
        node.style.top = `${y}%`;
        container.appendChild(node);
        
        // Keep constellation click event
        node.addEventListener('click', () => {
            node.classList.toggle('constellation-active');
            // Create burst effect
            for (let i = 0; i < 10; i++) {
                const angle = (i / 10) * Math.PI * 2;
                const rect = node.getBoundingClientRect();
                connectionParticles.push({
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2,
                    vx: Math.cos(angle) * 5,
                    vy: Math.sin(angle) * 5,
                    radius: 3,
                    opacity: 1,
                    color: containerId.includes('analyst') ? '#58a6ff' : '#67e97b'
                });
            }
        });
        
        const nodeData = { element: node, x, y, side: containerId.split('-')[0], skill: skill };
        nodeArray.push(nodeData);
        allNodes.push(nodeData);
    });
}

// Initialize project cards
function initializeProjectCards() {
    const cards = document.querySelectorAll('.project-card');
    cards.forEach(card => {
        const cardData = {
            element: card,
            type: 'project-card',
            side: 'project'
        };
        projectCards.push(cardData);
        allNodes.push(cardData);
    });
}

// Update connection particles
function updateConnectionParticles() {
    connectionParticles = connectionParticles.filter(particle => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.vx *= 0.98;
        particle.vy *= 0.98;
        particle.opacity *= 0.95;
        particle.radius *= 0.98;
        
        ctx.save();
        ctx.globalAlpha = particle.opacity;
        ctx.fillStyle = particle.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = particle.color;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        return particle.opacity > 0.01;
    });
}

// Main animation loop
function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    animationTime += 0.016;
    
    // Create occasional shooting stars
    createShootingStar();
    updateShootingStars();
    
    // Create mouse trail
    if (mouse.x && mouse.y) {
        createMouseTrail();
    }
    updateMouseTrails();
    
    // Render everything
    renderEnhancedStars();
    renderEnhancedConnections();
    updateConnectionParticles();
    
    requestAnimationFrame(animate);
}

// Mobile and touch detection
function detectMobile() {
    isMobile = window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    return isMobile;
}

// Touch event handlers
function handleTouchStart(e) {
    if (e.touches && e.touches.length > 0) {
        mouse.x = e.touches[0].clientX;
        mouse.y = e.touches[0].clientY;
    }
}

function handleTouchMove(e) {
    if (e.touches && e.touches.length > 0) {
        mouse.x = e.touches[0].clientX;
        mouse.y = e.touches[0].clientY;
        e.preventDefault();
    }
}

function handleTouchEnd(e) {
    setTimeout(() => {
        mouse.x = null;
        mouse.y = null;
    }, 500);
}

// Initialization
function init() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    detectMobile();
    createEnhancedStarField();
    createSkillNodes('analyst-skills', analystSkills);
    createSkillNodes('developer-skills', developerSkills);
    initializeProjectCards();
    
    // Mouse events for desktop
    window.addEventListener('mousemove', e => {
        if (!isTouch) {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        }
    });
    
    // Touch events for mobile
    if (isTouch) {
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: true });
    }
    
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        detectMobile();
        createEnhancedStarField();
    });
    
    // Start animation
    animate();
}

init();
});
</script>

</body>
</html>