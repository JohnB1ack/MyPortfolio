<!DOCTYPE HTML>
<html>
<head>
<title>John C. Black - Analyst & Developer</title>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />

<!-- Google Fonts & Font Awesome -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
:root {
--color-background: #0D1117;
--color-text-main: #E6EDF3;
--color-text-secondary: #8B949E;
--color-border: rgba(255, 255, 255, 0.1);
--font-main: 'Inter', sans-serif;
--glow-analyst: rgba(88, 166, 255, 0.2);
--glow-developer: rgba(67, 233, 123, 0.2);
--glass-bg: rgba(255, 255, 255, 0.05);
--glass-border: rgba(255, 255, 255, 0.15);
--glass-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
}

*, *::before, *::after {
box-sizing: border-box;
margin: 0;
padding: 0;
}

body {
background-color: var(--color-background);
font-family: var(--font-main);
color: var(--color-text-main);
overflow-x: hidden;
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;
-webkit-text-size-adjust: 100%;
-ms-text-size-adjust: 100%;
}

#canvas-background {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
z-index: 1;
background-color: var(--color-background);
background-image:
radial-gradient(ellipse at 15% 80%, var(--glow-analyst), transparent 50%),
radial-gradient(ellipse at 85% 80%, var(--glow-developer), transparent 50%);
}

#wrapper {
position: relative;
z-index: 2;
width: 100%;
min-height: 100vh;
display: flex;
flex-direction: column;
align-items: center;
padding: 2rem;
}

/* Profile section layout */
#profile-section {
display: flex;
justify-content: center;
align-items: center;
width: 100%;
max-width: 1400px;
min-height: 40vh;
padding: 5vh 2rem 2rem;
}

#profile-center {
width: 100%;
max-width: 600px;
text-align: center;
padding: 3rem 2rem;
position: relative;
z-index: 10;
/* Enhanced glassmorphism for standalone profile */
background: var(--glass-bg);
backdrop-filter: blur(15px);
-webkit-backdrop-filter: blur(15px);
border: 1px solid var(--glass-border);
border-radius: 24px;
box-shadow: var(--glass-shadow);
transition: all 0.3s ease;
}

#profile-center:hover {
transform: translateY(-5px);
box-shadow: 0 20px 50px rgba(0, 0, 0, 0.15), 0 0 20px rgba(255, 255, 255, 0.1);
border-color: rgba(255, 255, 255, 0.2);
}

#profile-center h1 {
font-size: clamp(2rem, 5vw, 3rem);
font-weight: 700;
color: var(--color-text-main);
margin-bottom: 1rem;
text-align: center;
}

#profile-center p {
font-size: 1.1rem;
line-height: 1.7;
color: var(--color-text-secondary);
max-width: 500px;
margin: 0 auto;
text-align: center;
}

/* Project Cards Section */
#project-grid {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
gap: 2rem;
width: 100%;
max-width: 1200px;
padding: 5rem 0;
}

.project-card {
/* Enhanced glassmorphism */
background: var(--glass-bg);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
border: 1px solid var(--glass-border);
border-radius: 16px;
padding: 2.5rem;
text-decoration: none;
color: inherit;
position: relative;
overflow: hidden;
transition: all 0.4s ease;
box-shadow: var(--glass-shadow);
-webkit-tap-highlight-color: rgba(88, 166, 255, 0.1);
touch-action: manipulation;
cursor: pointer;
}

.project-card::before {
content: '';
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), transparent);
opacity: 0;
transition: opacity 0.3s ease;
pointer-events: none;
}

.project-card:hover {
transform: translateY(-10px);
border-color: rgba(255, 255, 255, 0.3);
background: rgba(255, 255, 255, 0.08);
box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2), 0 0 20px rgba(255, 255, 255, 0.1);
}

.project-card:hover::before {
opacity: 1;
}

.project-card.active {
border-color: rgba(88, 166, 255, 0.4);
background: rgba(88, 166, 255, 0.08);
box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2), 0 0 30px rgba(88, 166, 255, 0.2);
}

.project-card.active::before {
background: linear-gradient(135deg, rgba(88, 166, 255, 0.1), rgba(67, 233, 123, 0.05));
opacity: 1;
}

.project-card.active .card-icon {
color: #58A6FF;
text-shadow: 0 0 15px rgba(88, 166, 255, 0.5);
transform: scale(1.1);
transition: all 0.3s ease;
}

.project-card.active .card-title {
color: #58A6FF;
text-shadow: 0 0 10px rgba(88, 166, 255, 0.3);
}

.card-icon {
font-size: 2.5rem;
margin-bottom: 1.5rem;
color: #58A6FF;
transition: all 0.3s ease;
}

.card-title {
font-size: 1.25rem;
font-weight: 700;
color: var(--color-text-main);
margin-bottom: 0.75rem;
transition: all 0.3s ease;
}

.card-description {
font-size: 0.95rem;
color: var(--color-text-secondary);
line-height: 1.7;
}

/* Message Card Special Styling */
.message-card {
background: linear-gradient(135deg, rgba(88, 166, 255, 0.08), rgba(67, 233, 123, 0.08)) !important;
border: 2px solid rgba(88, 166, 255, 0.3) !important;
position: relative;
overflow: hidden;
}

.message-card::before {
content: '';
position: absolute;
top: 0;
left: -100%;
width: 100%;
height: 100%;
background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
transition: left 0.5s ease;
}

.message-card:hover::before {
left: 100%;
}

.message-card:hover {
transform: translateY(-8px) !important;
box-shadow: 0 15px 40px rgba(88, 166, 255, 0.3) !important;
border-color: rgba(88, 166, 255, 0.6) !important;
}

.message-card .card-icon {
color: var(--glow-analyst) !important;
font-size: 3rem !important;
}

.message-card .card-title {
background: linear-gradient(135deg, var(--glow-analyst), var(--glow-developer));
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
}

.message-card .card-description {
color: var(--color-text-main) !important;
font-weight: 500;
}

.message-card.active {
border-color: rgba(67, 233, 123, 0.6) !important;
box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2), 0 0 40px rgba(67, 233, 123, 0.3) !important;
}

.message-card.active .card-icon {
color: #43E97B !important;
text-shadow: 0 0 20px rgba(67, 233, 123, 0.6) !important;
}

.message-card.active .card-title {
background: linear-gradient(135deg, #43E97B, #58A6FF) !important;
-webkit-background-clip: text !important;
-webkit-text-fill-color: transparent !important;
background-clip: text !important;
}

/* Marex Hub Card Styles */
.marex-hub-card {
position: relative;
overflow: visible !important;
cursor: pointer;
transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
/* Special styling with distinctive purple glow */
background: linear-gradient(135deg, var(--glass-bg), rgba(177, 156, 217, 0.04)) !important;
border: 1px solid rgba(177, 156, 217, 0.3) !important;
box-shadow:
    0 0 20px rgba(177, 156, 217, 0.15),
    0 0 40px rgba(177, 156, 217, 0.08),
    0 8px 32px rgba(0, 0, 0, 0.1),
    inset 0 1px 0 rgba(255, 255, 255, 0.1);
backdrop-filter: blur(12px);
-webkit-backdrop-filter: blur(12px);
/* Enhanced attention-drawing animations with amplified effects */
animation: marexGlow 3s ease-in-out infinite alternate, marexAttention 6s ease-in-out infinite, marexBorderPulse 4s ease-in-out infinite;
}

/* Shimmer effect overlay for attention */
.marex-hub-card::before {
content: '';
position: absolute;
top: 0;
left: -100%;
width: 100%;
height: 100%;
background: linear-gradient(
    90deg,
    transparent,
    rgba(177, 156, 217, 0.15),
    transparent
);
border-radius: inherit;
animation: marexShimmer 8s ease-in-out infinite;
pointer-events: none;
z-index: 1;
}

@keyframes marexGlow {
0% {
    box-shadow:
        0 0 25px rgba(177, 156, 217, 0.2),
        0 0 50px rgba(177, 156, 217, 0.12),
        0 8px 32px rgba(0, 0, 0, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
}
100% {
    box-shadow:
        0 0 40px rgba(177, 156, 217, 0.4),
        0 0 80px rgba(177, 156, 217, 0.2),
        0 12px 50px rgba(0, 0, 0, 0.15),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
}
}

/* Amplified attention-drawing pulsing border effect */
@keyframes marexAttention {
0%, 70%, 100% {
    border-color: rgba(177, 156, 217, 0.3);
    box-shadow:
        0 0 25px rgba(177, 156, 217, 0.2),
        0 0 50px rgba(177, 156, 217, 0.12),
        0 8px 32px rgba(0, 0, 0, 0.1);
}
15%, 55% {
    border-color: rgba(200, 180, 230, 0.8);
    transform: scale(1.008);
    box-shadow:
        0 0 45px rgba(200, 180, 230, 0.35),
        0 0 90px rgba(177, 156, 217, 0.25),
        0 15px 60px rgba(0, 0, 0, 0.15);
}
}

/* Border width pulsing animation */
@keyframes marexBorderPulse {
0%, 100% {
    border-width: 1px;
}
50% {
    border-width: 2px;
}
}

/* Shimmer sweep effect */
@keyframes marexShimmer {
0%, 90%, 100% { left: -100%; }
5%, 85% { left: 100%; }
}

.marex-main-card {
position: relative;
z-index: 2;
}

/* Click to expand indicator */
.marex-main-card::after {
content: 'Click to explore';
position: absolute;
bottom: 0.5rem;
left: 50%;
transform: translateX(-50%);
font-size: 0.7rem;
color: rgba(177, 156, 217, 0.7);
opacity: 0.8;
animation: expandHint 3s ease-in-out infinite;
pointer-events: none;
}

@keyframes expandHint {
0%, 70%, 100% {
    opacity: 0.6;
    transform: translateX(-50%) translateY(0);
}
35% {
    opacity: 1;
    transform: translateX(-50%) translateY(-2px);
}
}

.marex-hub-card:hover {
transform: translateY(-8px);
border-color: rgba(177, 156, 217, 0.4) !important;
box-shadow:
    0 0 30px rgba(177, 156, 217, 0.3),
    0 0 60px rgba(177, 156, 217, 0.15),
    0 15px 50px rgba(0, 0, 0, 0.15),
    inset 0 1px 0 rgba(255, 255, 255, 0.2);
animation: none; /* Pause breathing animation on hover */
}

.marex-main-card .card-title {
display: flex;
align-items: center;
justify-content: space-between;
}

.expand-indicator {
font-size: 0.8rem;
transition: transform 0.3s ease;
color: var(--color-text-secondary);
}

.marex-hub-card.expanded .expand-indicator {
transform: rotate(180deg);
color: #B19CD9;
}

.marex-hub-card.expanded {
box-shadow:
    0 0 35px rgba(177, 156, 217, 0.4),
    0 0 70px rgba(177, 156, 217, 0.2),
    0 20px 60px rgba(0, 0, 0, 0.2),
    inset 0 1px 0 rgba(255, 255, 255, 0.25);
animation: none; /* Stop breathing when expanded */
}

/* Hide click indicator when expanded */
.marex-hub-card.expanded .marex-main-card::after {
opacity: 0;
}

.project-count-badge {
position: absolute;
top: 1rem;
right: 1rem;
background: linear-gradient(135deg, rgba(177, 156, 217, 0.25), rgba(200, 180, 230, 0.15));
border: 1px solid rgba(177, 156, 217, 0.4);
border-radius: 12px;
padding: 0.25rem 0.75rem;
font-size: 0.75rem;
font-weight: 600;
color: #B19CD9;
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
box-shadow: 0 2px 8px rgba(177, 156, 217, 0.2);
/* Add amplified breathing animation with rotation */
animation: badgeBreathing 3s ease-in-out infinite, badgeRotation 6s ease-in-out infinite;
}

/* Amplified breathing animation for project count badge */
@keyframes badgeBreathing {
0%, 100% {
    transform: scale(1);
    border-color: rgba(177, 156, 217, 0.4);
    box-shadow: 0 2px 8px rgba(177, 156, 217, 0.2);
    background: linear-gradient(135deg, rgba(177, 156, 217, 0.25), rgba(200, 180, 230, 0.15));
}
50% {
    transform: scale(1.1);
    border-color: rgba(200, 180, 230, 0.8);
    box-shadow: 0 6px 18px rgba(200, 180, 230, 0.6);
    background: linear-gradient(135deg, rgba(200, 180, 230, 0.4), rgba(220, 200, 250, 0.25));
}
}

/* Subtle rotation animation for project count badge */
@keyframes badgeRotation {
0%, 100% {
    transform: rotate(0deg);
}
25% {
    transform: rotate(1deg);
}
75% {
    transform: rotate(-1deg);
}
}

.marex-sub-cards {
position: absolute;
top: 100%;
left: 0;
right: 0;
z-index: 1;
opacity: 0;
visibility: hidden;
transform: translateY(-20px);
transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
display: grid;
grid-template-columns: repeat(2, 1fr);
gap: 1rem;
padding: 1rem;
margin-top: 0.5rem;
background: var(--glass-bg);
backdrop-filter: blur(15px);
-webkit-backdrop-filter: blur(15px);
border: 1px solid var(--glass-border);
border-radius: 16px;
box-shadow: var(--glass-shadow);
}

.marex-hub-card.expanded .marex-sub-cards {
opacity: 1;
visibility: visible;
transform: translateY(0);
}

.sub-card {
/* Enhanced glassmorphism for sub-cards */
background: rgba(255, 255, 255, 0.03);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
border: 1px solid rgba(255, 255, 255, 0.1);
border-radius: 12px;
padding: 1.5rem;
text-decoration: none;
color: inherit;
position: relative;
overflow: hidden;
transition: all 0.3s ease;
cursor: pointer;
display: block;
}

.sub-card::before {
content: '';
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: linear-gradient(135deg, rgba(255, 255, 255, 0.05), transparent);
opacity: 0;
transition: opacity 0.3s ease;
pointer-events: none;
}

.sub-card:hover {
transform: translateY(-5px);
border-color: rgba(177, 156, 217, 0.3);
background: rgba(255, 255, 255, 0.06);
box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15), 0 0 15px rgba(177, 156, 217, 0.15);
}

.sub-card:hover::before {
opacity: 1;
}

.sub-card-icon {
font-size: 1.5rem;
margin-bottom: 0.75rem;
color: #58A6FF;
transition: all 0.3s ease;
}

.sub-card:hover .sub-card-icon {
color: #B19CD9;
transform: scale(1.1);
}

.sub-card-title {
font-size: 1rem;
font-weight: 600;
color: var(--color-text-main);
margin-bottom: 0.5rem;
transition: all 0.3s ease;
}

.sub-card:hover .sub-card-title {
color: #B19CD9;
}

.sub-card-description {
font-size: 0.85rem;
color: var(--color-text-secondary);
line-height: 1.5;
}

/* Amplified special highlighting for Data Hub Benefits sub-card */
.sub-card.data-insights {
position: relative;
border: 1px solid rgba(177, 156, 217, 0.6) !important;
background: linear-gradient(135deg, rgba(177, 156, 217, 0.12), rgba(200, 180, 230, 0.08)) !important;
animation: benefitsHighlight 4s ease-in-out infinite, benefitsBorderPulse 3s ease-in-out infinite, benefitsColorShift 8s ease-in-out infinite;
}

.sub-card.data-insights::after {
content: '';
position: absolute;
top: -2px;
left: -2px;
right: -2px;
bottom: -2px;
background: linear-gradient(135deg, rgba(177, 156, 217, 0.3), rgba(200, 180, 230, 0.2));
border-radius: inherit;
z-index: -1;
animation: benefitsGlow 3s ease-in-out infinite;
pointer-events: none;
}

.sub-card.data-insights:hover {
transform: translateY(-12px) !important;
border-color: rgba(220, 200, 250, 0.9) !important;
box-shadow:
    0 20px 50px rgba(200, 180, 230, 0.4),
    0 0 40px rgba(177, 156, 217, 0.35),
    0 0 60px rgba(220, 200, 250, 0.2) !important;
animation: benefitsHighlight 1.5s ease-in-out infinite, benefitsBorderPulse 2s ease-in-out infinite;
}

/* Amplified keyframes for Data Hub Benefits highlighting */
@keyframes benefitsHighlight {
0%, 100% {
    box-shadow:
        0 10px 30px rgba(177, 156, 217, 0.3),
        0 0 25px rgba(177, 156, 217, 0.15);
}
50% {
    box-shadow:
        0 15px 45px rgba(200, 180, 230, 0.5),
        0 0 40px rgba(177, 156, 217, 0.3);
}
}

@keyframes benefitsGlow {
0%, 100% {
    opacity: 0.4;
}
50% {
    opacity: 0.8;
}
}

/* Border pulsing animation for Data Hub Benefits */
@keyframes benefitsBorderPulse {
0%, 100% {
    border-width: 1px;
}
50% {
    border-width: 2px;
}
}

/* Color shifting animation for Data Hub Benefits */
@keyframes benefitsColorShift {
0%, 100% {
    background: linear-gradient(135deg, rgba(177, 156, 217, 0.12), rgba(200, 180, 230, 0.08));
}
50% {
    background: linear-gradient(135deg, rgba(200, 180, 230, 0.15), rgba(220, 200, 250, 0.1));
}
}

/* Mobile-specific layout */
@media (max-width: 1024px) {
#profile-section {
padding: 3rem 1rem 2rem;
min-height: 30vh;
}

#profile-center {
max-width: 500px;
padding: 2rem 1.5rem;
}
}

@media (max-width: 768px) {
#wrapper {
padding: 1rem;
}

#profile-section {
padding: 2rem 1rem 1.5rem;
min-height: 25vh;
}

#profile-center {
padding: 1.5rem;
max-width: 450px;
}

#profile-center h1 {
font-size: 2.2rem;
}

#profile-center p {
font-size: 1rem;
}

#project-grid {
padding: 2rem 0;
gap: 1.5rem;
grid-template-columns: 1fr;
}

.project-card {
padding: 2rem;
margin: 0 auto;
max-width: 400px;
}

.card-icon {
font-size: 2rem;
margin-bottom: 1rem;
}

.card-title {
font-size: 1.1rem;
}

.card-description {
font-size: 0.9rem;
}

/* Mobile Marex Hub Styles */
.marex-sub-cards {
grid-template-columns: 1fr;
gap: 1rem;
padding: 1rem;
}

.sub-card {
padding: 1.25rem;
}

.sub-card-icon {
font-size: 1.25rem;
margin-bottom: 0.5rem;
}

.sub-card-title {
font-size: 0.95rem;
}

.sub-card-description {
font-size: 0.8rem;
}

.project-count-badge {
font-size: 0.7rem;
padding: 0.2rem 0.6rem;
}

/* Mobile-optimized purple glow and effects */
@media (max-width: 768px) {
.marex-hub-card {
    box-shadow:
        0 0 15px rgba(177, 156, 217, 0.12),
        0 0 30px rgba(177, 156, 217, 0.06),
        0 6px 24px rgba(0, 0, 0, 0.08),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
}

.marex-hub-card:hover {
    box-shadow:
        0 0 20px rgba(177, 156, 217, 0.2),
        0 0 40px rgba(177, 156, 217, 0.1),
        0 10px 35px rgba(0, 0, 0, 0.12),
        inset 0 1px 0 rgba(255, 255, 255, 0.15);
}

/* Mobile click indicator */
.marex-main-card::after {
    font-size: 0.65rem;
    bottom: 0.3rem;
}

/* Mobile Data Hub Benefits highlighting - amplified */
.sub-card.data-insights {
    animation: benefitsHighlight 5s ease-in-out infinite, benefitsColorShift 10s ease-in-out infinite;
}

/* Mobile badge breathing - enhanced */
.project-count-badge {
    animation: badgeBreathing 4s ease-in-out infinite;
}
}

@keyframes marexGlow {
    0% {
        box-shadow:
            0 0 15px rgba(177, 156, 217, 0.12),
            0 0 30px rgba(177, 156, 217, 0.06),
            0 6px 24px rgba(0, 0, 0, 0.08),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    100% {
        box-shadow:
            0 0 18px rgba(177, 156, 217, 0.18),
            0 0 35px rgba(177, 156, 217, 0.09),
            0 8px 30px rgba(0, 0, 0, 0.1),
            inset 0 1px 0 rgba(255, 255, 255, 0.12);
    }
}

@media (max-width: 480px) {
#wrapper {
padding: 0.75rem;
}

#profile-section {
padding: 1.5rem 0.75rem 1rem;
min-height: 20vh;
}

#profile-center {
padding: 1.25rem;
max-width: 350px;
}

#profile-center h1 {
font-size: 1.8rem;
}

#profile-center p {
font-size: 0.9rem;
padding: 0 0.5rem;
}

#project-grid {
gap: 1rem;
padding: 1.5rem 0;
}

.project-card {
padding: 1.5rem;
border-radius: 12px;
}

.card-icon {
font-size: 1.8rem;
}

.card-title {
font-size: 1rem;
}

.card-description {
font-size: 0.85rem;
line-height: 1.5;
}

/* Mobile Marex Hub Adjustments */
.marex-sub-cards {
padding: 0.75rem;
gap: 0.75rem;
}

.sub-card {
padding: 1rem;
}

.sub-card-icon {
font-size: 1.1rem;
}

.sub-card-title {
font-size: 0.9rem;
}

.sub-card-description {
font-size: 0.75rem;
}

.project-count-badge {
font-size: 0.65rem;
padding: 0.15rem 0.5rem;
top: 0.75rem;
right: 0.75rem;
}
}

@media (max-width: 360px) {
#profile-center {
padding: 1rem;
max-width: 300px;
}

#profile-center h1 {
font-size: 1.6rem;
}

.project-card {
padding: 1.25rem;
}
}

/* Mobile-specific enhancements */
@media (hover: none) and (pointer: coarse) {
.project-card:active {
transform: translateY(-5px) scale(0.98);
border-color: rgba(88, 166, 255, 0.5);
}
}

/* Reduce motion for users who prefer it */
@media (prefers-reduced-motion: reduce) {
.project-card,
.skill-node,
.card-icon,
.card-title {
transition: none;
}
}

/* Hide original theme elements to prevent conflicts */
#main, #header, #nav, #intro { display: none !important; }
#wrapper { display: flex !important; }
</style>
</head>
<body>

<canvas id="canvas-background"></canvas>

<div id="wrapper">
<section id="profile-section">
<div id="profile-center">
<h1>John C. Black</h1>
<p>A builder at the intersection of finance and technology, transforming complex problems into elegant automation solutions.</p>
</div>
</section>

<section id="project-grid">
<a href="about-me.html" class="project-card user-experience">
<i class="card-icon fas fa-user-astronaut"></i>
<h3 class="card-title">About Me</h3>
<p class="card-description">Learn about my journey from operations to innovation and my approach to solving complex challenges.</p>
</a>

<div class="project-card marex-hub-card" id="marex-hub">
<div class="marex-main-card">
<i class="card-icon fas fa-building"></i>
<h3 class="card-title">Marex Portfolio <i class="expand-indicator fas fa-chevron-down"></i></h3>
<p class="card-description">Explore my comprehensive suite of automation solutions that transformed operations at Marex, from reporting platforms to data processing engines.</p>
<div class="project-count-badge">4 Projects</div>
</div>

<div class="marex-sub-cards" id="marex-sub-cards">
<a href="streamlit-report-generator.html" class="sub-card dashboard-development financial-analysis">
<i class="sub-card-icon fas fa-chart-line"></i>
<h4 class="sub-card-title">Reporting Platform</h4>
<p class="sub-card-description">A unified platform serving as a centralized hub for reporting needs across departments.</p>
</a>

<a href="interest-rate-automation.html" class="sub-card automation-platform risk-automation">
<i class="sub-card-icon fas fa-cogs"></i>
<h4 class="sub-card-title">Automation Engine</h4>
<p class="sub-card-description">Discover how a custom solution reduced daily processing from 4 hours to 15 minutes.</p>
</a>

<a href="xtp-data-integration.html" class="sub-card data-platform system-integration">
<i class="sub-card-icon fas fa-database"></i>
<h4 class="sub-card-title">Data Processing</h4>
<p class="sub-card-description">Enhanced collaboration through Alteryx workflows, empowering teams with direct data access.</p>
</a>

<a href="benefits.html" class="sub-card data-insights business-value">
<i class="sub-card-icon fas fa-chart-pie"></i>
<h4 class="sub-card-title">Data Hub Benefits</h4>
<p class="sub-card-description">Discover the transformative value of unified data access and the ROI of automated data pipelines.</p>
</a>
</div>
</div>

<a href="https://www.linkedin.com/in/john-black-532677194/" target="_blank" class="project-card message-card">
<i class="card-icon fas fa-envelope"></i>
<h3 class="card-title">Message Me</h3>
<p class="card-description">Ready to discuss automation opportunities? Let's connect and explore how citizen development can transform your processes.</p>
</a>
</section>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {

// --- SIMPLIFIED CONFIGURATION ---

// --- SCRIPT LOGIC ---
const canvas = document.getElementById('canvas-background');
const ctx = canvas.getContext('2d');
let mouse = { x: null, y: null };
const allNodes = [];
const projectCards = [];
let animationTime = 0;
let isMobile = false;
let isTouch = false;

// Enhanced star system
let stars = [];
let nebulaClouds = [];
let shootingStars = [];
let mouseTrails = [];
let connectionParticles = [];
let glassShards = [];

// Realistic star colors based on stellar classification
const starColors = [
    '#ffffff',    // White (most common)
    '#fff8f0',    // Warm white
    '#fffaf5',    // Cool white
    '#fff5e6',    // Slightly warm
    '#f8f8ff',    // Blue-white (hot stars)
    '#fff0e6',    // Warm yellow-white
    '#ffeaa7',    // Yellow (sun-like)
    '#ffcc99'     // Orange (cooler stars)
];

// Create glass shard particles for mobile effects
function createGlassShards(x, y, count = 10) {
    for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * i) / count;
        glassShards.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * (2 + Math.random() * 3),
            vy: Math.sin(angle) * (2 + Math.random() * 3),
            size: Math.random() * 3 + 1,
            opacity: 0.6,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 0.2
        });
    }
}

// Update glass shards
function updateGlassShards() {
    glassShards = glassShards.filter(shard => {
        shard.x += shard.vx;
        shard.y += shard.vy;
        shard.vy += 0.1; // gravity
        shard.opacity *= 0.98;
        shard.rotation += shard.rotationSpeed;
        
        ctx.save();
        ctx.globalAlpha = shard.opacity;
        ctx.translate(shard.x, shard.y);
        ctx.rotate(shard.rotation);
        
        // Draw glass shard
        const gradient = ctx.createLinearGradient(-shard.size, -shard.size, shard.size, shard.size);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
        gradient.addColorStop(0.5, 'rgba(88, 166, 255, 0.4)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0.2)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(-shard.size, -shard.size, shard.size * 2, shard.size * 2);
        
        ctx.restore();
        
        return shard.opacity > 0.01;
    });
}

// Create enhanced star field with various effects
function createEnhancedStarField() {
    stars = [];
    nebulaClouds = [];

    // Create main stars with enhanced variety
    const starCount = isMobile ? 150 : 300; // Increased density for better connections
    for (let i = 0; i < starCount; i++) {
        const starType = Math.random();
        let radius, opacity, twinkleSpeed, color, isSpecial;

        if (starType < 0.8) {
            // Regular white/dim stars (80%)
            radius = Math.random() * 1.2 + 0.3;
            opacity = Math.random() * 0.5 + 0.3;
            twinkleSpeed = Math.random() * 0.012 + 0.005;
            color = Math.random() < 0.9 ? '#ffffff' : starColors[Math.floor(Math.random() * 3)]; // Mostly white
            isSpecial = false;
        } else if (starType < 0.95) {
            // Brighter stars with subtle color (15%)
            radius = Math.random() * 2 + 0.8;
            opacity = Math.random() * 0.4 + 0.6;
            twinkleSpeed = Math.random() * 0.018 + 0.008;
            color = starColors[Math.floor(Math.random() * 5)]; // Subtle natural colors
            isSpecial = false;
        } else {
            // Rare bright stars (5%)
            radius = Math.random() * 2.5 + 1.2;
            opacity = Math.random() * 0.3 + 0.7;
            twinkleSpeed = Math.random() * 0.02 + 0.01;
            color = starColors[Math.floor(Math.random() * starColors.length)];
            isSpecial = true;
        }

        stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            radius: radius,
            baseOpacity: opacity,
            opacity: opacity,
            twinkleSpeed: twinkleSpeed,
            twinklePhase: Math.random() * Math.PI * 2,
            color: color,
            pulseSpeed: Math.random() * 0.8 + 0.4,
            isSpecial: isSpecial,
            z: Math.random() * 0.5 + 0.5, // depth for parallax
            connectionStrength: 0 // for mouse interaction feedback
        });
    }

    // Create subtle nebula clouds for depth
    const nebulaCount = isMobile ? 3 : 6;
    for (let i = 0; i < nebulaCount; i++) {
        nebulaClouds.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            radius: Math.random() * 250 + 150,
            color: Math.random() < 0.5 ? 'rgba(88, 166, 255, 0.02)' : 'rgba(173, 216, 255, 0.015)',
            drift: {
                x: (Math.random() - 0.5) * 0.03,
                y: (Math.random() - 0.5) * 0.03
            },
            pulsePhase: Math.random() * Math.PI * 2,
            pulseSpeed: Math.random() * 0.5 + 0.2
        });
    }
}

// Create shooting star effect
function createShootingStar() {
    if (shootingStars.length < 2 && Math.random() < 0.001) {
        const startX = Math.random() * canvas.width;
        const startY = Math.random() * canvas.height * 0.5;
        const angle = Math.random() * Math.PI / 4 + Math.PI / 6;
        
        shootingStars.push({
            x: startX,
            y: startY,
            length: Math.random() * 80 + 40,
            speed: Math.random() * 4 + 2,
            angle: angle,
            opacity: 1,
            trail: []
        });
    }
}

// Update shooting stars
function updateShootingStars() {
    shootingStars = shootingStars.filter(star => {
        star.x += Math.cos(star.angle) * star.speed;
        star.y += Math.sin(star.angle) * star.speed;
        star.opacity *= 0.98;
        
        // Add to trail
        star.trail.push({ x: star.x, y: star.y, opacity: star.opacity });
        if (star.trail.length > 15) star.trail.shift();
        
        return star.opacity > 0.01 && star.x < canvas.width && star.y < canvas.height;
    });
}

// Create enhanced mouse trail particles
function createMouseTrail() {
    if (mouse.x && mouse.y && mouseTrails.length < (isMobile ? 15 : 25)) {
        // Calculate mouse velocity for dynamic trail
        const currentTime = Date.now();
        if (mouse.lastX !== undefined && mouse.lastY !== undefined && mouse.lastTime !== undefined) {
            const deltaTime = currentTime - mouse.lastTime;
            const deltaX = mouse.x - mouse.lastX;
            const deltaY = mouse.y - mouse.lastY;
            const velocity = Math.sqrt(deltaX * deltaX + deltaY * deltaY) / deltaTime;

            // Create trail particles based on movement
            if (velocity > 0.1) { // Only create trail when moving
                mouseTrails.push({
                    x: mouse.x + (Math.random() - 0.5) * 8,
                    y: mouse.y + (Math.random() - 0.5) * 8,
                    vx: (Math.random() - 0.5) * 0.8 - deltaX * 0.02,
                    vy: (Math.random() - 0.5) * 0.8 - deltaY * 0.02,
                    radius: Math.random() * 1.5 + 0.3,
                    opacity: Math.min(0.6, velocity * 1.5),
                    color: Math.random() < 0.8 ? '#ffffff' : '#f0f8ff',
                    life: 1.0
                });
            }
        }

        // Store current position for next frame
        mouse.lastX = mouse.x;
        mouse.lastY = mouse.y;
        mouse.lastTime = currentTime;
    }
}

// Update enhanced mouse trails
function updateMouseTrails() {
    mouseTrails = mouseTrails.filter(trail => {
        trail.x += trail.vx;
        trail.y += trail.vy;
        trail.vx *= 0.98; // Slight deceleration
        trail.vy *= 0.98;
        trail.life *= 0.96; // Life-based fading
        trail.opacity = trail.life * 0.8;
        trail.radius *= 0.99; // Slower radius decay
        return trail.life > 0.02;
    });
}

// Enhanced star rendering with twinkling and special effects
function renderEnhancedStars() {
    // Render enhanced nebula clouds for atmospheric depth
    nebulaClouds.forEach(cloud => {
        // Dynamic pulsing effect
        const pulse = Math.sin(animationTime * cloud.pulseSpeed + cloud.pulsePhase) * 0.3 + 0.7;
        const effectiveRadius = cloud.radius * pulse;

        // Create multi-layered gradient for depth
        const gradient = ctx.createRadialGradient(cloud.x, cloud.y, 0, cloud.x, cloud.y, effectiveRadius);

        // Enhanced color with subtle animation
        const baseOpacity = 0.02 + Math.sin(animationTime * 0.5 + cloud.pulsePhase) * 0.005;
        const colorWithPulse = cloud.color.replace(/[\d.]+\)$/, `${baseOpacity})`);

        gradient.addColorStop(0, colorWithPulse);
        gradient.addColorStop(0.4, colorWithPulse.replace(/[\d.]+\)$/, `${baseOpacity * 0.6})`));
        gradient.addColorStop(1, 'transparent');

        ctx.save();
        ctx.fillStyle = gradient;
        ctx.fillRect(cloud.x - effectiveRadius, cloud.y - effectiveRadius, effectiveRadius * 2, effectiveRadius * 2);
        ctx.restore();

        // Smooth drift with slight acceleration
        cloud.x += cloud.drift.x * (1 + Math.sin(animationTime * 0.1) * 0.2);
        cloud.y += cloud.drift.y * (1 + Math.cos(animationTime * 0.1) * 0.2);

        // Wrap around screen with buffer
        const buffer = cloud.radius * 0.5;
        if (cloud.x < -buffer) cloud.x = canvas.width + buffer;
        if (cloud.x > canvas.width + buffer) cloud.x = -buffer;
        if (cloud.y < -buffer) cloud.y = canvas.height + buffer;
        if (cloud.y > canvas.height + buffer) cloud.y = -buffer;
    });
    
    // Update star connection strength and render with enhanced effects
    stars.forEach(star => {
        // Calculate mouse interaction
        let connectionStrength = 0;
        if (mouse.x && mouse.y) {
            const dx = star.x - mouse.x;
            const dy = star.y - mouse.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const connectionRange = isMobile ? 150 : 200;

            if (dist < connectionRange) {
                connectionStrength = Math.pow(1 - dist / connectionRange, 2);
            }
        }

        // Smooth connection strength transition
        star.connectionStrength += (connectionStrength - star.connectionStrength) * 0.1;

        // Enhanced twinkling with connection influence
        const twinkle = Math.sin(animationTime * star.twinkleSpeed + star.twinklePhase) * 0.5 + 0.5;
        const pulse = star.isSpecial ? Math.sin(animationTime * star.pulseSpeed) * 0.3 + 0.7 : 1;
        const connectionBoost = 1 + star.connectionStrength * 0.8;

        ctx.save();
        ctx.globalAlpha = star.baseOpacity * twinkle * pulse * connectionBoost;

        // Enhanced rendering based on connection strength
        const effectiveRadius = star.radius * (1 + star.connectionStrength * 0.5);
        const glowIntensity = star.connectionStrength * 0.6;

        // Special stars get extra effects
        if (star.isSpecial || star.connectionStrength > 0.1) {
            // Outer glow with connection enhancement
            const glowRadius = star.radius * (6 + star.connectionStrength * 4);
            const gradient = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, glowRadius);

            if (star.connectionStrength > 0.1) {
                gradient.addColorStop(0, `rgba(255, 255, 255, ${glowIntensity * 0.6})`);
                gradient.addColorStop(0.3, `rgba(240, 248, 255, ${glowIntensity * 0.4})`);
                gradient.addColorStop(0.6, star.color);
            } else {
                gradient.addColorStop(0, star.color);
                gradient.addColorStop(0.3, star.color);
            }
            gradient.addColorStop(1, 'transparent');

            ctx.fillStyle = gradient;
            ctx.fillRect(star.x - glowRadius, star.y - glowRadius, glowRadius * 2, glowRadius * 2);

            // Core with enhanced glow
            ctx.shadowBlur = 8 + glowIntensity * 10;
            ctx.shadowColor = star.connectionStrength > 0.1 ? 'rgba(240, 248, 255, 0.6)' : star.color;
        } else {
            ctx.shadowBlur = 3;
            ctx.shadowColor = star.color;
        }

        // Main star body
        ctx.fillStyle = star.connectionStrength > 0.1 ?
            `rgba(255, 255, 255, ${0.8 + star.connectionStrength * 0.2})` :
            star.color;
        ctx.beginPath();
        ctx.arc(star.x, star.y, effectiveRadius, 0, Math.PI * 2);
        ctx.fill();

        // Add cross pattern for bright stars or connected stars
        if (star.radius > 1.5 || star.connectionStrength > 0.2) {
            ctx.globalAlpha *= 0.6;
            ctx.strokeStyle = star.connectionStrength > 0.2 ?
                'rgba(255, 255, 255, 0.6)' :
                star.color;
            ctx.lineWidth = 0.5 + star.connectionStrength;
            ctx.beginPath();
            const crossSize = effectiveRadius * 2.5;
            ctx.moveTo(star.x - crossSize, star.y);
            ctx.lineTo(star.x + crossSize, star.y);
            ctx.moveTo(star.x, star.y - crossSize);
            ctx.lineTo(star.x, star.y + crossSize);
            ctx.stroke();
        }

        ctx.restore();
    });
    
    // Render shooting stars
    shootingStars.forEach(star => {
        ctx.save();
        
        // Draw trail
        star.trail.forEach((point, index) => {
            if (index < star.trail.length - 1) {
                const nextPoint = star.trail[index + 1];
                const gradient = ctx.createLinearGradient(point.x, point.y, nextPoint.x, nextPoint.y);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${point.opacity * 0.2})`);
                gradient.addColorStop(1, `rgba(255, 255, 255, ${nextPoint.opacity * 0.5})`);
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(point.x, point.y);
                ctx.lineTo(nextPoint.x, nextPoint.y);
                ctx.stroke();
            }
        });
        
        // Draw head
        ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
        ctx.shadowBlur = 8;
        ctx.shadowColor = '#ffffff';
        ctx.beginPath();
        ctx.arc(star.x, star.y, 1.5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    });
    
    // Render enhanced mouse trails
    mouseTrails.forEach(trail => {
        ctx.save();

        // Create gradient for trail particle
        const gradient = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, trail.radius * 3);
        gradient.addColorStop(0, `rgba(255, 255, 255, ${trail.opacity * 0.8})`);
        gradient.addColorStop(0.4, trail.color.replace('rgb', 'rgba').replace(')', `, ${trail.opacity * 0.6})`));
        gradient.addColorStop(1, 'transparent');

        ctx.fillStyle = gradient;
        ctx.fillRect(trail.x - trail.radius * 3, trail.y - trail.radius * 3, trail.radius * 6, trail.radius * 6);

        // Core particle
        ctx.globalAlpha = trail.opacity;
        ctx.fillStyle = trail.color;
        ctx.shadowBlur = 6;
        ctx.shadowColor = trail.color;
        ctx.beginPath();
        ctx.arc(trail.x, trail.y, trail.radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    });
}

// Enhanced mouse connection lines with particles and gradients
function renderEnhancedConnections() {
    if (!mouse.x || !mouse.y) return;

    // Enhanced mouse-to-star connection system
    const starConnectionRange = isMobile ? 150 : 200;
    const connectedStars = [];

    // First pass: identify connected stars and sort by distance for performance
    stars.forEach(star => {
        const dx = star.x - mouse.x;
        const dy = star.y - mouse.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < starConnectionRange) {
            connectedStars.push({ star, dist, dx, dy });
        }
    });

    // Sort by distance for layered rendering (furthest first)
    connectedStars.sort((a, b) => b.dist - a.dist);

    // Render connections with enhanced effects
    connectedStars.forEach(({ star, dist, dx, dy }) => {
        // Calculate opacity with smooth falloff
        const normalizedDist = dist / starConnectionRange;
        const opacity = Math.pow(1 - normalizedDist, 2) * 0.6; // Quadratic falloff for smoother fade

        // Subtle realistic gradient
        const gradient = ctx.createLinearGradient(mouse.x, mouse.y, star.x, star.y);
        gradient.addColorStop(0, `rgba(255, 255, 255, ${opacity * 0.6})`);
        gradient.addColorStop(0.3, `rgba(240, 248, 255, ${opacity * 0.8})`);
        gradient.addColorStop(0.7, `rgba(220, 235, 255, ${opacity * 0.6})`);
        gradient.addColorStop(1, `rgba(255, 255, 255, ${opacity * 0.2})`);

        ctx.save();

        // Main connection line with enhanced glow
        ctx.strokeStyle = gradient;
        ctx.lineWidth = isMobile ? 1.5 : 2;
        ctx.shadowBlur = 8;
        ctx.shadowColor = `rgba(220, 235, 255, ${opacity * 0.5})`;
        ctx.beginPath();
        ctx.moveTo(mouse.x, mouse.y);
        ctx.lineTo(star.x, star.y);
        ctx.stroke();

        // Add subtle secondary glow
        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.3})`;
        ctx.lineWidth = isMobile ? 0.5 : 1;
        ctx.shadowBlur = 15;
        ctx.shadowColor = `rgba(240, 248, 255, ${opacity * 0.4})`;
        ctx.stroke();

        // Subtle star enhancement when connected
        const starGlow = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, star.radius * 3);
        starGlow.addColorStop(0, `rgba(255, 255, 255, ${opacity * 0.4})`);
        starGlow.addColorStop(0.5, `rgba(240, 248, 255, ${opacity * 0.2})`);
        starGlow.addColorStop(1, 'transparent');

        ctx.fillStyle = starGlow;
        ctx.fillRect(star.x - star.radius * 3, star.y - star.radius * 3, star.radius * 6, star.radius * 6);

        ctx.restore();

        // Add energy pulse along connection line for closest stars
        if (dist < starConnectionRange * 0.5) {
            const pulsePos = (animationTime * 2 + dist * 0.01) % 1;
            const pulseX = mouse.x + (star.x - mouse.x) * pulsePos;
            const pulseY = mouse.y + (star.y - mouse.y) * pulsePos;

            ctx.save();
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.8})`;
            ctx.shadowBlur = 8;
            ctx.shadowColor = `rgba(88, 166, 255, ${opacity})`;
            ctx.beginPath();
            ctx.arc(pulseX, pulseY, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    });

    // Enhanced mouse cursor with dynamic glow
    if (connectedStars.length > 0) {
        ctx.save();

        // Calculate glow intensity based on connections
        const maxConnections = Math.min(connectedStars.length, 8);
        const glowIntensity = Math.min(maxConnections / 8, 1);
        const glowRadius = 15 + glowIntensity * 25;

        // Subtle cursor glow
        const cursorGlow = ctx.createRadialGradient(mouse.x, mouse.y, 0, mouse.x, mouse.y, glowRadius);
        cursorGlow.addColorStop(0, `rgba(255, 255, 255, ${0.3 + glowIntensity * 0.3})`);
        cursorGlow.addColorStop(0.3, `rgba(248, 252, 255, ${0.2 + glowIntensity * 0.2})`);
        cursorGlow.addColorStop(0.6, `rgba(240, 248, 255, ${0.1 + glowIntensity * 0.1})`);
        cursorGlow.addColorStop(1, 'transparent');

        ctx.fillStyle = cursorGlow;
        ctx.fillRect(mouse.x - glowRadius, mouse.y - glowRadius, glowRadius * 2, glowRadius * 2);

        // Add subtle pulsing center point
        const pulseSize = 1.5 + Math.sin(animationTime * 3) * 0.5;
        ctx.fillStyle = `rgba(255, 255, 255, ${0.6 + glowIntensity * 0.2})`;
        ctx.shadowBlur = 6;
        ctx.shadowColor = 'rgba(240, 248, 255, 0.6)';
        ctx.beginPath();
        ctx.arc(mouse.x, mouse.y, pulseSize, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    // Handle project cards with enhanced effects
    allNodes.forEach(node => {
        const rect = node.element.getBoundingClientRect();
        const nodeCenterX = rect.left + rect.width / 2;
        const nodeCenterY = rect.top + rect.height / 2;

        const dist = Math.sqrt(Math.pow(nodeCenterX - mouse.x, 2) + Math.pow(nodeCenterY - mouse.y, 2));

        // Handle project cards with enhanced effects
        if (node.type === 'project-card') {
            const cardRange = isMobile ? 200 : 300;
            if (dist < cardRange) {
                node.element.classList.add('active');
                
                const baseOpacity = 0.6 * (1 - dist / cardRange);
                const isMessageCard = node.element.classList.contains('message-card');
                
                // Simplified effects for mobile
                if (isMobile) {
                    // Simple gradient line
                    const gradient = ctx.createLinearGradient(mouse.x, mouse.y, nodeCenterX, nodeCenterY);
                    const color = isMessageCard ? '67, 233, 123' : '88, 166, 255';
                    gradient.addColorStop(0, `rgba(${color}, ${baseOpacity * 0.2})`);
                    gradient.addColorStop(0.5, `rgba(${color}, ${baseOpacity})`);
                    gradient.addColorStop(1, `rgba(${color}, ${baseOpacity * 0.2})`);
                    
                    ctx.save();
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = `rgba(${color}, 0.5)`;
                    ctx.beginPath();
                    ctx.moveTo(mouse.x, mouse.y);
                    ctx.lineTo(nodeCenterX, nodeCenterY);
                    ctx.stroke();
                    ctx.restore();
                } else {
                    // Desktop effects remain the same
                    if (isMessageCard) {
                        ctx.save();
                        
                        // Draw spiral path
                        ctx.beginPath();
                        const steps = 40;
                        for (let i = 0; i <= steps; i++) {
                            const t = i / steps;
                            const spiral = t * Math.PI * 2;
                            const radius = t * 15;
                            const x = mouse.x + (nodeCenterX - mouse.x) * t + Math.cos(spiral + animationTime * 2) * radius * (1 - t);
                            const y = mouse.y + (nodeCenterY - mouse.y) * t + Math.sin(spiral + animationTime * 2) * radius * (1 - t);
                            
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        
                        const gradient = ctx.createLinearGradient(mouse.x, mouse.y, nodeCenterX, nodeCenterY);
                        gradient.addColorStop(0, `rgba(67, 233, 123, ${baseOpacity * 0.3})`);
                        gradient.addColorStop(0.5, `rgba(88, 166, 255, ${baseOpacity})`);
                        gradient.addColorStop(1, `rgba(67, 233, 123, ${baseOpacity * 0.3})`);
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = 'rgba(67, 233, 123, 0.5)';
                        ctx.stroke();
                        
                        ctx.restore();
                    } else {
                        // Regular project cards with wave effect
                        ctx.save();
                        
                        ctx.beginPath();
                        const steps = 25;
                        for (let i = 0; i <= steps; i++) {
                            const t = i / steps;
                            const wave = Math.sin(t * Math.PI * 3 + animationTime * 3) * 8;
                            const perpX = -(nodeCenterY - mouse.y) / dist;
                            const perpY = (nodeCenterX - mouse.x) / dist;
                            
                            const x = mouse.x + (nodeCenterX - mouse.x) * t + perpX * wave * (1 - Math.abs(t - 0.5) * 2);
                            const y = mouse.y + (nodeCenterY - mouse.y) * t + perpY * wave * (1 - Math.abs(t - 0.5) * 2);
                            
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        
                        const gradient = ctx.createLinearGradient(mouse.x, mouse.y, nodeCenterX, nodeCenterY);
                        gradient.addColorStop(0, `rgba(88, 166, 255, ${baseOpacity * 0.2})`);
                        gradient.addColorStop(0.5, `rgba(88, 166, 255, ${baseOpacity})`);
                        gradient.addColorStop(1, `rgba(88, 166, 255, ${baseOpacity * 0.2})`);
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = 'rgba(88, 166, 255, 0.5)';
                        ctx.stroke();
                        
                        ctx.restore();
                    }
                }
                
                // Add glow at both ends (simplified for mobile)
                ctx.save();
                ctx.fillStyle = isMessageCard ? 'rgba(67, 233, 123, 0.8)' : 'rgba(88, 166, 255, 0.8)';
                ctx.shadowBlur = 15;
                ctx.shadowColor = ctx.fillStyle;
                ctx.globalAlpha = baseOpacity;
                
                // Mouse end
                ctx.beginPath();
                ctx.arc(mouse.x, mouse.y, isMobile ? 3 : 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Node end
                ctx.beginPath();
                ctx.arc(nodeCenterX, nodeCenterY, isMobile ? 5 : 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                
            } else {
                node.element.classList.remove('active');
            }
        }
    });
}



// Initialize project cards
function initializeProjectCards() {
    const cards = document.querySelectorAll('.project-card');
    cards.forEach(card => {
        const cardData = {
            element: card,
            type: 'project-card',
            side: 'project'
        };
        projectCards.push(cardData);
        allNodes.push(cardData);
    });
}

// Initialize Marex Hub Card functionality
function initializeMarexHub() {
    const marexHub = document.getElementById('marex-hub');
    const marexMainCard = marexHub.querySelector('.marex-main-card');
    const subCards = document.querySelectorAll('.sub-card');
    let isExpanded = false;

    // Add click handler for main card
    marexMainCard.addEventListener('click', function(e) {
        e.preventDefault();
        toggleMarexHub();
    });

    // Add hover effects for desktop
    if (!isMobile) {
        marexHub.addEventListener('mouseenter', function() {
            if (!isExpanded) {
                this.style.transform = 'translateY(-5px) scale(1.02)';
            }
        });

        marexHub.addEventListener('mouseleave', function() {
            if (!isExpanded) {
                this.style.transform = '';
            }
        });
    }

    // Toggle function
    function toggleMarexHub() {
        isExpanded = !isExpanded;

        if (isExpanded) {
            marexHub.classList.add('expanded');

            // Create expansion particle effect
            const rect = marexMainCard.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            // Create purple burst effect for Marex card
            for (let i = 0; i < 15; i++) {
                const angle = (i / 15) * Math.PI * 2;
                connectionParticles.push({
                    x: centerX,
                    y: centerY,
                    vx: Math.cos(angle) * 5,
                    vy: Math.sin(angle) * 5,
                    radius: 2.5,
                    opacity: 0.9,
                    color: '#B19CD9'
                });
            }

            // Add secondary ring of smaller particles
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + Math.PI / 8;
                connectionParticles.push({
                    x: centerX,
                    y: centerY,
                    vx: Math.cos(angle) * 3,
                    vy: Math.sin(angle) * 3,
                    radius: 1.5,
                    opacity: 0.7,
                    color: '#C8B4E6'
                });
            }

            // Animate sub-cards with stagger
            subCards.forEach((card, index) => {
                setTimeout(() => {
                    card.style.transform = 'translateY(0) scale(1)';
                    card.style.opacity = '1';
                }, index * 100);
            });

        } else {
            marexHub.classList.remove('expanded');

            // Reset sub-card animations
            subCards.forEach(card => {
                card.style.transform = '';
                card.style.opacity = '';
            });
        }
    }

    // Add sub-card hover effects with purple particles
    subCards.forEach(subCard => {
        subCard.addEventListener('mouseenter', function() {
            // Create subtle purple particle effect
            const rect = this.getBoundingClientRect();
            for (let i = 0; i < 4; i++) {
                connectionParticles.push({
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2,
                    vx: (Math.random() - 0.5) * 2.5,
                    vy: (Math.random() - 0.5) * 2.5,
                    radius: 1.2,
                    opacity: 0.7,
                    color: Math.random() < 0.7 ? '#B19CD9' : '#C8B4E6'
                });
            }
        });
    });

    // Close on outside click
    document.addEventListener('click', function(e) {
        if (isExpanded && !marexHub.contains(e.target)) {
            toggleMarexHub();
        }
    });

    // Close on escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && isExpanded) {
            toggleMarexHub();
        }
    });
}

// Update connection particles
function updateConnectionParticles() {
    connectionParticles = connectionParticles.filter(particle => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.vx *= 0.98;
        particle.vy *= 0.98;
        particle.opacity *= 0.95;
        particle.radius *= 0.98;
        
        ctx.save();
        ctx.globalAlpha = particle.opacity;
        ctx.fillStyle = particle.color;
        ctx.shadowBlur = 8;
        ctx.shadowColor = particle.color;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        return particle.opacity > 0.01;
    });
}

// Main animation loop
function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    animationTime += 0.016;
    
    // Create occasional shooting stars (less frequent on mobile)
    if (!isMobile || Math.random() < 0.0005) {
        createShootingStar();
    }
    updateShootingStars();
    
    // Create mouse trail (fewer particles on mobile)
    if (mouse.x && mouse.y && (!isMobile || mouseTrails.length < 10)) {
        createMouseTrail();
    }
    updateMouseTrails();
    
    // Render everything
    renderEnhancedStars();
    renderEnhancedConnections();
    updateConnectionParticles();
    updateGlassShards();
    
    requestAnimationFrame(animate);
}

// Mobile and touch detection
function detectMobile() {
    isMobile = window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    return isMobile;
}

// Touch event handlers
function handleTouchStart(e) {
    if (e.touches && e.touches.length > 0) {
        mouse.x = e.touches[0].clientX;
        mouse.y = e.touches[0].clientY;
    }
}

function handleTouchMove(e) {
    if (e.touches && e.touches.length > 0) {
        mouse.x = e.touches[0].clientX;
        mouse.y = e.touches[0].clientY;
        // Don't prevent default on mobile to allow scrolling
    }
}

function handleTouchEnd(e) {
    setTimeout(() => {
        mouse.x = null;
        mouse.y = null;
    }, 300);
}



// Initialization
function init() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    detectMobile();
    createEnhancedStarField();
    initializeProjectCards();
    initializeMarexHub();
    
    // Mouse events for desktop
    window.addEventListener('mousemove', e => {
        if (!isTouch) {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        }
    });
    
    // Touch events for mobile
    if (isTouch) {
        canvas.addEventListener('touchstart', handleTouchStart, { passive: true });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: true });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: true });
    }
    
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const wasMobile = isMobile;
        detectMobile();
        
        // If switching between mobile and desktop, rebuild the interface
        if (wasMobile !== isMobile) {
            // Clear existing nodes
            allNodes.length = 0;
            projectCards.length = 0;

            // Rebuild
            initializeProjectCards();
            initializeMarexHub();
        }
        
        createEnhancedStarField();
    });
    
    // Start animation
    animate();
}

init();
});
</script>

</body>
</html>