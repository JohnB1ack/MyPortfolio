<!DOCTYPE HTML>
<html>
<head>
<title>John C. Black - Analyst & Developer</title>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />

<!-- Google Fonts & Font Awesome -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
:root {
--color-background: #0D1117;
--color-text-main: #E6EDF3;
--color-text-secondary: #8B949E;
--color-border: rgba(255, 255, 255, 0.1);
--font-main: 'Inter', sans-serif;
--glow-analyst: rgba(88, 166, 255, 0.2);
--glow-developer: rgba(67, 233, 123, 0.2);
--glass-bg: rgba(255, 255, 255, 0.05);
--glass-border: rgba(255, 255, 255, 0.15);
--glass-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
}

*, *::before, *::after {
box-sizing: border-box;
margin: 0;
padding: 0;
}

body {
background-color: var(--color-background);
font-family: var(--font-main);
color: var(--color-text-main);
overflow-x: hidden;
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;
-webkit-text-size-adjust: 100%;
-ms-text-size-adjust: 100%;
}

#canvas-background {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
z-index: 1;
background-color: var(--color-background);
background-image:
radial-gradient(ellipse at 15% 80%, var(--glow-analyst), transparent 50%),
radial-gradient(ellipse at 85% 80%, var(--glow-developer), transparent 50%);
}

#wrapper {
position: relative;
z-index: 2;
width: 100%;
min-height: 100vh;
display: flex;
flex-direction: column;
align-items: center;
padding: 2rem;
}

/* Main hero layout */
#mindset-container {
display: flex;
justify-content: center;
align-items: flex-start;
width: 100%;
max-width: 1400px;
min-height: 70vh;
padding-top: 5vh;
}

.mindset-side {
flex: 1;
padding: 2rem;
height: 60vh;
position: relative;
}

.mindset-side h2 {
font-size: clamp(1.5rem, 4vw, 2rem);
font-weight: 700;
color: var(--color-text-secondary);
text-align: center;
margin-bottom: 2rem;
position: relative;
z-index: 3;
/* Glassmorphism for headers */
background: var(--glass-bg);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
border: 1px solid var(--glass-border);
border-radius: 16px;
padding: 1rem 1.5rem;
box-shadow: var(--glass-shadow);
}

#analyst-side h2 { text-align: right; }
#developer-side h2 { text-align: left; }

.skills-cloud {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
}

.skill-node {
position: absolute;
font-size: clamp(0.8rem, 1.5vw, 1rem);
font-weight: 500;
padding: 8px 16px;
/* Enhanced glassmorphism */
background: var(--glass-bg);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
border: 1px solid var(--glass-border);
border-radius: 20px;
color: var(--color-text-secondary);
white-space: nowrap;
transform: translate(-50%, -50%);
transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
z-index: 2;
cursor: pointer;
-webkit-tap-highlight-color: transparent;
user-select: none;
-webkit-user-select: none;
box-shadow: var(--glass-shadow);
}

.skill-node:hover {
border-color: var(--glow-analyst);
background: rgba(255, 255, 255, 0.08);
transform: translate(-50%, -50%) scale(1.05);
box-shadow: 0 0 20px rgba(88, 166, 255, 0.3), var(--glass-shadow);
}

.skill-node:active {
transform: translate(-50%, -50%) scale(0.95);
}

.skill-node.constellation-active {
border-color: #58a6ff;
background: rgba(88, 166, 255, 0.15);
color: #58a6ff;
text-shadow: 0 0 15px rgba(88, 166, 255, 0.8);
box-shadow:
    0 0 30px rgba(88, 166, 255, 0.5),
    inset 0 0 20px rgba(88, 166, 255, 0.1);
animation: constellation-pulse 2s ease-in-out infinite;
}

@keyframes constellation-pulse {
0%, 100% {
    box-shadow:
        0 0 30px rgba(88, 166, 255, 0.5),
        inset 0 0 20px rgba(88, 166, 255, 0.1);
}
50% {
    box-shadow:
        0 0 40px rgba(88, 166, 255, 0.8),
        inset 0 0 25px rgba(88, 166, 255, 0.2);
}
}

.skill-node.active {
color: var(--color-text-main);
text-shadow: 0 0 10px currentColor;
}

#analyst-side .skill-node.active { color: #80bfff; }
#developer-side .skill-node.active { color: #72f7b1; }

#profile-center {
flex: 0 0 auto;
width: 300px;
text-align: center;
padding: 2rem 1rem;
margin-top: 4rem;
position: relative;
z-index: 10;
/* Glassmorphism for profile */
background: var(--glass-bg);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
border: 1px solid var(--glass-border);
border-radius: 24px;
box-shadow: var(--glass-shadow);
}

#profile-center h1 {
font-size: clamp(2rem, 5vw, 3rem);
font-weight: 700;
color: var(--color-text-main);
margin-bottom: 1rem;
text-align: center;
}

#profile-center p {
font-size: 1.1rem;
line-height: 1.7;
color: var(--color-text-secondary);
max-width: 500px;
margin: 0 auto;
text-align: center;
}

/* Project Cards Section */
#project-grid {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
gap: 2rem;
width: 100%;
max-width: 1200px;
padding: 5rem 0;
}

.project-card {
/* Enhanced glassmorphism */
background: var(--glass-bg);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
border: 1px solid var(--glass-border);
border-radius: 16px;
padding: 2.5rem;
text-decoration: none;
color: inherit;
position: relative;
overflow: hidden;
transition: all 0.4s ease;
box-shadow: var(--glass-shadow);
-webkit-tap-highlight-color: rgba(88, 166, 255, 0.1);
touch-action: manipulation;
cursor: pointer;
}

.project-card::before {
content: '';
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), transparent);
opacity: 0;
transition: opacity 0.3s ease;
pointer-events: none;
}

.project-card:hover {
transform: translateY(-10px);
border-color: rgba(255, 255, 255, 0.3);
background: rgba(255, 255, 255, 0.08);
box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2), 0 0 20px rgba(255, 255, 255, 0.1);
}

.project-card:hover::before {
opacity: 1;
}

.project-card.active {
border-color: rgba(88, 166, 255, 0.4);
background: rgba(88, 166, 255, 0.08);
box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2), 0 0 30px rgba(88, 166, 255, 0.2);
}

.project-card.active::before {
background: linear-gradient(135deg, rgba(88, 166, 255, 0.1), rgba(67, 233, 123, 0.05));
opacity: 1;
}

.project-card.active .card-icon {
color: #58A6FF;
text-shadow: 0 0 15px rgba(88, 166, 255, 0.5);
transform: scale(1.1);
transition: all 0.3s ease;
}

.project-card.active .card-title {
color: #58A6FF;
text-shadow: 0 0 10px rgba(88, 166, 255, 0.3);
}

.card-icon {
font-size: 2.5rem;
margin-bottom: 1.5rem;
color: #58A6FF;
transition: all 0.3s ease;
}

.card-title {
font-size: 1.25rem;
font-weight: 700;
color: var(--color-text-main);
margin-bottom: 0.75rem;
transition: all 0.3s ease;
}

.card-description {
font-size: 0.95rem;
color: var(--color-text-secondary);
line-height: 1.7;
}

/* Message Card Special Styling */
.message-card {
background: linear-gradient(135deg, rgba(88, 166, 255, 0.08), rgba(67, 233, 123, 0.08)) !important;
border: 2px solid rgba(88, 166, 255, 0.3) !important;
position: relative;
overflow: hidden;
}

.message-card::before {
content: '';
position: absolute;
top: 0;
left: -100%;
width: 100%;
height: 100%;
background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
transition: left 0.5s ease;
}

.message-card:hover::before {
left: 100%;
}

.message-card:hover {
transform: translateY(-8px) !important;
box-shadow: 0 15px 40px rgba(88, 166, 255, 0.3) !important;
border-color: rgba(88, 166, 255, 0.6) !important;
}

.message-card .card-icon {
color: var(--glow-analyst) !important;
font-size: 3rem !important;
}

.message-card .card-title {
background: linear-gradient(135deg, var(--glow-analyst), var(--glow-developer));
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
}

.message-card .card-description {
color: var(--color-text-main) !important;
font-weight: 500;
}

.message-card.active {
border-color: rgba(67, 233, 123, 0.6) !important;
box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2), 0 0 40px rgba(67, 233, 123, 0.3) !important;
}

.message-card.active .card-icon {
color: #43E97B !important;
text-shadow: 0 0 20px rgba(67, 233, 123, 0.6) !important;
}

.message-card.active .card-title {
background: linear-gradient(135deg, #43E97B, #58A6FF) !important;
-webkit-background-clip: text !important;
-webkit-text-fill-color: transparent !important;
background-clip: text !important;
}

/* Mobile-specific structured layout */
@media (max-width: 1024px) {
#mindset-container {
flex-direction: column;
align-items: center;
min-height: unset;
padding-top: 2rem;
}

.mindset-side {
width: 100%;
max-width: 600px;
height: auto;
padding: 1rem;
margin-bottom: 2rem;
/* Glass card for mobile */
background: var(--glass-bg);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
border: 1px solid var(--glass-border);
border-radius: 24px;
box-shadow: var(--glass-shadow);
}

.mindset-side h2 {
margin-bottom: 1.5rem;
text-align: center !important;
background: none;
border: none;
box-shadow: none;
padding: 0;
}

.skills-cloud {
position: relative;
display: grid;
grid-template-columns: repeat(2, 1fr);
gap: 1rem;
padding: 1rem;
}

.skill-node {
position: relative !important;
left: auto !important;
top: auto !important;
transform: none !important;
width: 100%;
text-align: center;
padding: 12px 16px;
}

.skill-node:hover {
transform: scale(1.02) !important;
}

.skill-node:active {
transform: scale(0.98) !important;
}

#analyst-side { order: 2; }
#profile-center { 
order: 1; 
margin-top: 0;
margin-bottom: 2rem;
width: 100%;
max-width: 500px;
}
#developer-side { order: 3; }
}

@media (max-width: 768px) {
#wrapper {
padding: 1rem;
}

#mindset-container {
padding-top: 1rem;
}

.mindset-side {
padding: 1rem;
margin-bottom: 1.5rem;
}

.skills-cloud {
grid-template-columns: 1fr;
gap: 0.75rem;
}

#profile-center {
padding: 1.5rem;
margin-bottom: 1.5rem;
}

#profile-center h1 {
font-size: 2.2rem;
}

#profile-center p {
font-size: 1rem;
}

#project-grid {
padding: 2rem 0;
gap: 1.5rem;
grid-template-columns: 1fr;
}

.project-card {
padding: 2rem;
margin: 0 auto;
max-width: 400px;
}

.card-icon {
font-size: 2rem;
margin-bottom: 1rem;
}

.card-title {
font-size: 1.1rem;
}

.card-description {
font-size: 0.9rem;
}
}

@media (max-width: 480px) {
#wrapper {
padding: 0.75rem;
}

.mindset-side {
padding: 0.75rem;
margin-bottom: 1rem;
}

.mindset-side h2 {
font-size: 1.3rem;
margin-bottom: 1rem;
}

.skills-cloud {
gap: 0.5rem;
padding: 0.5rem;
}

.skill-node {
font-size: 0.8rem;
padding: 10px 14px;
}

#profile-center {
padding: 1.25rem;
}

#profile-center h1 {
font-size: 1.8rem;
}

#profile-center p {
font-size: 0.9rem;
padding: 0 0.5rem;
}

#project-grid {
gap: 1rem;
padding: 1.5rem 0;
}

.project-card {
padding: 1.5rem;
border-radius: 12px;
}

.card-icon {
font-size: 1.8rem;
}

.card-title {
font-size: 1rem;
}

.card-description {
font-size: 0.85rem;
line-height: 1.5;
}
}

@media (max-width: 360px) {
.mindset-side {
padding: 0.5rem;
}

.skill-node {
font-size: 0.75rem;
padding: 8px 12px;
}

#profile-center h1 {
font-size: 1.6rem;
}

.project-card {
padding: 1.25rem;
}
}

/* Mobile-specific enhancements */
@media (hover: none) and (pointer: coarse) {
.project-card:active {
transform: translateY(-5px) scale(0.98);
border-color: rgba(88, 166, 255, 0.5);
}

/* Enable skill node interactions on mobile */
.skill-node {
pointer-events: auto !important;
}
}

/* Reduce motion for users who prefer it */
@media (prefers-reduced-motion: reduce) {
.project-card,
.skill-node,
.card-icon,
.card-title {
transition: none;
}
}

/* Hide original theme elements to prevent conflicts */
#main, #header, #nav, #intro { display: none !important; }
#wrapper { display: flex !important; }

/* Mobile collapse animation */
.skills-cloud.collapsed {
max-height: 0;
overflow: hidden;
opacity: 0;
transition: all 0.3s ease;
}

.skills-cloud.expanded {
max-height: 1000px;
opacity: 1;
transition: all 0.3s ease;
}
</style>
</head>
<body>

<canvas id="canvas-background"></canvas>

<div id="wrapper">
<section id="mindset-container">

<div id="analyst-side" class="mindset-side">
<h2>Futures Brokerage Analyst</h2>
<div id="analyst-skills" class="skills-cloud expanded"></div>
</div>

<div id="profile-center">
<h1>John C. Black</h1>
<p>A builder at the intersection of finance and technology, transforming complex problems into elegant automation solutions.</p>
</div>

<div id="developer-side" class="mindset-side">
<h2>Citizen Developer</h2>
<div id="developer-skills" class="skills-cloud expanded"></div>
</div>

</section>

<section id="project-grid">
<a href="about-me.html" class="project-card user-experience">
<i class="card-icon fas fa-user-astronaut"></i>
<h3 class="card-title">About Me</h3>
<p class="card-description">Learn about my journey from operations to innovation and my approach to solving complex challenges.</p>
</a>

<a href="streamlit-report-generator.html" class="project-card dashboard-development financial-analysis">
<i class="card-icon fas fa-chart-line"></i>
<h3 class="card-title">Reporting Platform</h3>
<p class="card-description">A unified platform serving as a centralized hub for reporting needs across departments.</p>
</a>

<a href="interest-rate-automation.html" class="project-card automation-platform risk-automation">
<i class="card-icon fas fa-cogs"></i>
<h3 class="card-title">Automation Engine</h3>
<p class="card-description">Discover how a custom solution reduced daily processing from 4 hours to 15 minutes.</p>
</a>

<a href="xtp-data-integration.html" class="project-card data-platform system-integration">
<i class="card-icon fas fa-database"></i>
<h3 class="card-title">Data Processing</h3>
<p class="card-description">Enhanced collaboration through Alteryx workflows, empowering teams with direct data access.</p>
</a>

<a href="generic.html" class="project-card ai-development">
<i class="card-icon fas fa-code"></i>
<h3 class="card-title">Foundational Skills</h3>
<p class="card-description">Where it all began: SQL & SAS taught me patience and the mission to make data work for people.</p>
</a>

<a href="https://www.linkedin.com/in/john-black-532677194/" target="_blank" class="project-card message-card">
<i class="card-icon fas fa-envelope"></i>
<h3 class="card-title">Message Me</h3>
<p class="card-description">Ready to discuss automation opportunities? Let's connect and explore how citizen development can transform your processes.</p>
</a>
</section>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {

// --- CONFIGURATION: EDIT YOUR SKILLS AND QUALITIES HERE ---
const analystSkills = [
{ name: 'Financial Reporting', constellationStars: [] },
{ name: 'Risk Management', constellationStars: [] },
{ name: 'Trade Reconciliation', constellationStars: [] },
{ name: 'Data-Driven Analysis', constellationStars: [] },
{ name: 'Futures Settlement', constellationStars: [] },
{ name: 'Operational Efficiency', constellationStars: [] },
{ name: 'Regulatory Compliance', constellationStars: [] },
{ name: 'Financial System Integrity', constellationStars: [] }
];

const developerSkills = [
{ name: 'Python Process Automation', constellationStars: [] },
{ name: 'AI/ML Frameworks', constellationStars: [] },
{ name: 'API Integration', constellationStars: [] },
{ name: 'Data Pipeline Architecture', constellationStars: [] },
{ name: 'Alteryx Development', constellationStars: [] },
{ name: 'System Integration', constellationStars: [] },
{ name: 'Interactive Dashboards', constellationStars: [] },
{ name: 'User Empowerment Focus', constellationStars: [] }
];

// --- SCRIPT LOGIC ---
const canvas = document.getElementById('canvas-background');
const ctx = canvas.getContext('2d');
let mouse = { x: null, y: null };
const allNodes = [];
const projectCards = [];
let animationTime = 0;
let isMobile = false;
let isTouch = false;

// Enhanced star system
let stars = [];
let nebulaClouds = [];
let shootingStars = [];
let mouseTrails = [];
let connectionParticles = [];
let glassShards = [];

// Enhanced visual configuration
const starColors = [
    '#ffffff', '#ffe9c4', '#c4e9ff', '#ffc4c4', '#c4ffc4', '#e9c4ff',
    '#58a6ff', '#67e97b', '#ff6b6b', '#ffd93d', '#6bcf7f', '#c47eff'
];

// Create glass shard particles for mobile effects
function createGlassShards(x, y, count = 10) {
    for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * i) / count;
        glassShards.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * (2 + Math.random() * 3),
            vy: Math.sin(angle) * (2 + Math.random() * 3),
            size: Math.random() * 3 + 1,
            opacity: 0.6,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 0.2
        });
    }
}

// Update glass shards
function updateGlassShards() {
    glassShards = glassShards.filter(shard => {
        shard.x += shard.vx;
        shard.y += shard.vy;
        shard.vy += 0.1; // gravity
        shard.opacity *= 0.98;
        shard.rotation += shard.rotationSpeed;
        
        ctx.save();
        ctx.globalAlpha = shard.opacity;
        ctx.translate(shard.x, shard.y);
        ctx.rotate(shard.rotation);
        
        // Draw glass shard
        const gradient = ctx.createLinearGradient(-shard.size, -shard.size, shard.size, shard.size);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
        gradient.addColorStop(0.5, 'rgba(88, 166, 255, 0.4)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0.2)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(-shard.size, -shard.size, shard.size * 2, shard.size * 2);
        
        ctx.restore();
        
        return shard.opacity > 0.01;
    });
}

// Create enhanced star field with various effects
function createEnhancedStarField() {
    stars = [];
    nebulaClouds = [];
    
    // Create main stars with varied properties
    const starCount = isMobile ? 100 : 250;
    for (let i = 0; i < starCount; i++) {
        stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            radius: Math.random() * 2 + 0.5,
            opacity: Math.random() * 0.8 + 0.2,
            twinkleSpeed: Math.random() * 0.02 + 0.01,
            twinklePhase: Math.random() * Math.PI * 2,
            color: starColors[Math.floor(Math.random() * starColors.length)],
            pulseSpeed: Math.random() * 0.5 + 0.5,
            isSpecial: Math.random() < 0.1, // 10% chance for special stars
            z: Math.random() * 0.5 + 0.5 // depth for parallax
        });
    }
    
    // Create nebula clouds for depth
    const nebulaCount = isMobile ? 2 : 5;
    for (let i = 0; i < nebulaCount; i++) {
        nebulaClouds.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            radius: Math.random() * 200 + 100,
            color: Math.random() < 0.5 ? 'rgba(88, 166, 255, 0.03)' : 'rgba(67, 233, 123, 0.03)',
            drift: {
                x: (Math.random() - 0.5) * 0.05,
                y: (Math.random() - 0.5) * 0.05
            }
        });
    }
}

// Create shooting star effect
function createShootingStar() {
    if (shootingStars.length < 2 && Math.random() < 0.001) {
        const startX = Math.random() * canvas.width;
        const startY = Math.random() * canvas.height * 0.5;
        const angle = Math.random() * Math.PI / 4 + Math.PI / 6;
        
        shootingStars.push({
            x: startX,
            y: startY,
            length: Math.random() * 80 + 40,
            speed: Math.random() * 4 + 2,
            angle: angle,
            opacity: 1,
            trail: []
        });
    }
}

// Update shooting stars
function updateShootingStars() {
    shootingStars = shootingStars.filter(star => {
        star.x += Math.cos(star.angle) * star.speed;
        star.y += Math.sin(star.angle) * star.speed;
        star.opacity *= 0.98;
        
        // Add to trail
        star.trail.push({ x: star.x, y: star.y, opacity: star.opacity });
        if (star.trail.length > 15) star.trail.shift();
        
        return star.opacity > 0.01 && star.x < canvas.width && star.y < canvas.height;
    });
}

// Create mouse trail particles
function createMouseTrail() {
    if (mouse.x && mouse.y && mouseTrails.length < 20) {
        mouseTrails.push({
            x: mouse.x,
            y: mouse.y,
            vx: (Math.random() - 0.5) * 1.5,
            vy: (Math.random() - 0.5) * 1.5,
            radius: Math.random() * 2 + 0.5,
            opacity: 0.6,
            color: Math.random() < 0.5 ? '#58a6ff' : '#67e97b'
        });
    }
}

// Update mouse trails
function updateMouseTrails() {
    mouseTrails = mouseTrails.filter(trail => {
        trail.x += trail.vx;
        trail.y += trail.vy;
        trail.opacity *= 0.95;
        trail.radius *= 0.98;
        return trail.opacity > 0.01;
    });
}

// Enhanced star rendering with twinkling and special effects
function renderEnhancedStars() {
    // Render nebula clouds first for background effect
    nebulaClouds.forEach(cloud => {
        const gradient = ctx.createRadialGradient(cloud.x, cloud.y, 0, cloud.x, cloud.y, cloud.radius);
        gradient.addColorStop(0, cloud.color);
        gradient.addColorStop(1, 'transparent');
        
        ctx.save();
        ctx.fillStyle = gradient;
        ctx.fillRect(cloud.x - cloud.radius, cloud.y - cloud.radius, cloud.radius * 2, cloud.radius * 2);
        ctx.restore();
        
        // Drift nebula
        cloud.x += cloud.drift.x;
        cloud.y += cloud.drift.y;
        
        // Wrap around screen
        if (cloud.x < -cloud.radius) cloud.x = canvas.width + cloud.radius;
        if (cloud.x > canvas.width + cloud.radius) cloud.x = -cloud.radius;
        if (cloud.y < -cloud.radius) cloud.y = canvas.height + cloud.radius;
        if (cloud.y > canvas.height + cloud.radius) cloud.y = -cloud.radius;
    });
    
    // Render stars with enhanced effects
    stars.forEach(star => {
        const twinkle = Math.sin(animationTime * star.twinkleSpeed + star.twinklePhase) * 0.5 + 0.5;
        const pulse = star.isSpecial ? Math.sin(animationTime * star.pulseSpeed) * 0.3 + 0.7 : 1;
        
        ctx.save();
        ctx.globalAlpha = star.opacity * twinkle * pulse;
        
        // Special stars get extra effects
        if (star.isSpecial) {
            // Outer glow
            const gradient = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, star.radius * 6);
            gradient.addColorStop(0, star.color);
            gradient.addColorStop(0.3, star.color);
            gradient.addColorStop(1, 'transparent');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(star.x - star.radius * 6, star.y - star.radius * 6, star.radius * 12, star.radius * 12);
            
            // Core with enhanced glow
            ctx.shadowBlur = 10;
            ctx.shadowColor = star.color;
        } else {
            ctx.shadowBlur = 3;
            ctx.shadowColor = star.color;
        }
        
        ctx.fillStyle = star.color;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Add cross pattern for bright stars
        if (star.radius > 1.5) {
            ctx.globalAlpha *= 0.4;
            ctx.strokeStyle = star.color;
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(star.x - star.radius * 2, star.y);
            ctx.lineTo(star.x + star.radius * 2, star.y);
            ctx.moveTo(star.x, star.y - star.radius * 2);
            ctx.lineTo(star.x, star.y + star.radius * 2);
            ctx.stroke();
        }
        
        ctx.restore();
    });
    
    // Render shooting stars
    shootingStars.forEach(star => {
        ctx.save();
        
        // Draw trail
        star.trail.forEach((point, index) => {
            if (index < star.trail.length - 1) {
                const nextPoint = star.trail[index + 1];
                const gradient = ctx.createLinearGradient(point.x, point.y, nextPoint.x, nextPoint.y);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${point.opacity * 0.2})`);
                gradient.addColorStop(1, `rgba(255, 255, 255, ${nextPoint.opacity * 0.5})`);
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(point.x, point.y);
                ctx.lineTo(nextPoint.x, nextPoint.y);
                ctx.stroke();
            }
        });
        
        // Draw head
        ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
        ctx.shadowBlur = 8;
        ctx.shadowColor = '#ffffff';
        ctx.beginPath();
        ctx.arc(star.x, star.y, 1.5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    });
    
    // Render mouse trails
    mouseTrails.forEach(trail => {
        ctx.save();
        ctx.globalAlpha = trail.opacity;
        ctx.fillStyle = trail.color;
        ctx.shadowBlur = 8;
        ctx.shadowColor = trail.color;
        ctx.beginPath();
        ctx.arc(trail.x, trail.y, trail.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    });
}

// Enhanced mouse connection lines with particles and gradients
function renderEnhancedConnections() {
    if (!mouse.x || !mouse.y) return;
    
    const mouseSide = (mouse.x < window.innerWidth / 2) ? 'analyst' : 'developer';
    
    allNodes.forEach(node => {
        const rect = node.element.getBoundingClientRect();
        const nodeCenterX = rect.left + rect.width / 2;
        const nodeCenterY = rect.top + rect.height / 2;
        
        const dist = Math.sqrt(Math.pow(nodeCenterX - mouse.x, 2) + Math.pow(nodeCenterY - mouse.y, 2));
        
        // Handle skill nodes
        if (node.type !== 'project-card') {
            const skillRange = isMobile ? 250 : 400;
            if (!isMobile && node.side === mouseSide && dist < skillRange || isMobile && dist < skillRange) {
                node.element.classList.add('active');
                
                // Create gradient for connection line
                const gradient = ctx.createLinearGradient(mouse.x, mouse.y, nodeCenterX, nodeCenterY);
                const baseColor = node.side === 'analyst' ? '88, 166, 255' : '67, 233, 123';
                const opacity = 0.8 * (1 - dist / skillRange);
                
                gradient.addColorStop(0, `rgba(${baseColor}, ${opacity * 0.2})`);
                gradient.addColorStop(0.5, `rgba(${baseColor}, ${opacity})`);
                gradient.addColorStop(1, `rgba(${baseColor}, ${opacity * 0.2})`);
                
                // Draw main connection line with glow
                ctx.save();
                ctx.strokeStyle = gradient;
                ctx.lineWidth = isMobile ? 2 : 3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = `rgba(${baseColor}, ${opacity})`;
                ctx.beginPath();
                ctx.moveTo(mouse.x, mouse.y);
                ctx.lineTo(nodeCenterX, nodeCenterY);
                ctx.stroke();
                
                // Draw energy pulse along line
                const pulsePos = (animationTime * 3) % 1;
                const pulseX = mouse.x + (nodeCenterX - mouse.x) * pulsePos;
                const pulseY = mouse.y + (nodeCenterY - mouse.y) * pulsePos;
                
                ctx.fillStyle = `rgba(${baseColor}, ${opacity * 1.5})`;
                ctx.shadowBlur = 12;
                ctx.beginPath();
                ctx.arc(pulseX, pulseY, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw particles along connection (fewer on mobile)
                const particleCount = isMobile ? 3 : 5;
                for (let i = 0; i < particleCount; i++) {
                    const particlePos = (pulsePos + i * (1 / particleCount)) % 1;
                    const px = mouse.x + (nodeCenterX - mouse.x) * particlePos;
                    const py = mouse.y + (nodeCenterY - mouse.y) * particlePos;
                    
                    ctx.fillStyle = `rgba(${baseColor}, ${opacity * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(px, py, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
                
                // Add star burst at node position (simplified for mobile)
                if (!isMobile) {
                    ctx.save();
                    ctx.globalAlpha = opacity * 0.3;
                    ctx.strokeStyle = `rgb(${baseColor})`;
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2 + animationTime;
                        const x1 = nodeCenterX + Math.cos(angle) * 8;
                        const y1 = nodeCenterY + Math.sin(angle) * 8;
                        const x2 = nodeCenterX + Math.cos(angle) * 16;
                        const y2 = nodeCenterY + Math.sin(angle) * 16;
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
                
            } else {
                node.element.classList.remove('active');
            }
        }
        // Handle project cards with enhanced effects
        else {
            const cardRange = isMobile ? 200 : 300;
            if (dist < cardRange) {
                node.element.classList.add('active');
                
                const baseOpacity = 0.6 * (1 - dist / cardRange);
                const isMessageCard = node.element.classList.contains('message-card');
                
                // Simplified effects for mobile
                if (isMobile) {
                    // Simple gradient line
                    const gradient = ctx.createLinearGradient(mouse.x, mouse.y, nodeCenterX, nodeCenterY);
                    const color = isMessageCard ? '67, 233, 123' : '88, 166, 255';
                    gradient.addColorStop(0, `rgba(${color}, ${baseOpacity * 0.2})`);
                    gradient.addColorStop(0.5, `rgba(${color}, ${baseOpacity})`);
                    gradient.addColorStop(1, `rgba(${color}, ${baseOpacity * 0.2})`);
                    
                    ctx.save();
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = `rgba(${color}, 0.5)`;
                    ctx.beginPath();
                    ctx.moveTo(mouse.x, mouse.y);
                    ctx.lineTo(nodeCenterX, nodeCenterY);
                    ctx.stroke();
                    ctx.restore();
                } else {
                    // Desktop effects remain the same
                    if (isMessageCard) {
                        ctx.save();
                        
                        // Draw spiral path
                        ctx.beginPath();
                        const steps = 40;
                        for (let i = 0; i <= steps; i++) {
                            const t = i / steps;
                            const spiral = t * Math.PI * 2;
                            const radius = t * 15;
                            const x = mouse.x + (nodeCenterX - mouse.x) * t + Math.cos(spiral + animationTime * 2) * radius * (1 - t);
                            const y = mouse.y + (nodeCenterY - mouse.y) * t + Math.sin(spiral + animationTime * 2) * radius * (1 - t);
                            
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        
                        const gradient = ctx.createLinearGradient(mouse.x, mouse.y, nodeCenterX, nodeCenterY);
                        gradient.addColorStop(0, `rgba(67, 233, 123, ${baseOpacity * 0.3})`);
                        gradient.addColorStop(0.5, `rgba(88, 166, 255, ${baseOpacity})`);
                        gradient.addColorStop(1, `rgba(67, 233, 123, ${baseOpacity * 0.3})`);
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = 'rgba(67, 233, 123, 0.5)';
                        ctx.stroke();
                        
                        ctx.restore();
                    } else {
                        // Regular project cards with wave effect
                        ctx.save();
                        
                        ctx.beginPath();
                        const steps = 25;
                        for (let i = 0; i <= steps; i++) {
                            const t = i / steps;
                            const wave = Math.sin(t * Math.PI * 3 + animationTime * 3) * 8;
                            const perpX = -(nodeCenterY - mouse.y) / dist;
                            const perpY = (nodeCenterX - mouse.x) / dist;
                            
                            const x = mouse.x + (nodeCenterX - mouse.x) * t + perpX * wave * (1 - Math.abs(t - 0.5) * 2);
                            const y = mouse.y + (nodeCenterY - mouse.y) * t + perpY * wave * (1 - Math.abs(t - 0.5) * 2);
                            
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        
                        const gradient = ctx.createLinearGradient(mouse.x, mouse.y, nodeCenterX, nodeCenterY);
                        gradient.addColorStop(0, `rgba(88, 166, 255, ${baseOpacity * 0.2})`);
                        gradient.addColorStop(0.5, `rgba(88, 166, 255, ${baseOpacity})`);
                        gradient.addColorStop(1, `rgba(88, 166, 255, ${baseOpacity * 0.2})`);
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = 'rgba(88, 166, 255, 0.5)';
                        ctx.stroke();
                        
                        ctx.restore();
                    }
                }
                
                // Add glow at both ends (simplified for mobile)
                ctx.save();
                ctx.fillStyle = isMessageCard ? 'rgba(67, 233, 123, 0.8)' : 'rgba(88, 166, 255, 0.8)';
                ctx.shadowBlur = 15;
                ctx.shadowColor = ctx.fillStyle;
                ctx.globalAlpha = baseOpacity;
                
                // Mouse end
                ctx.beginPath();
                ctx.arc(mouse.x, mouse.y, isMobile ? 3 : 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Node end
                ctx.beginPath();
                ctx.arc(nodeCenterX, nodeCenterY, isMobile ? 5 : 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                
            } else {
                node.element.classList.remove('active');
            }
        }
    });
}

// Skill placement function with mobile-optimized layout
function createSkillNodes(containerId, skills) {
    const container = document.getElementById(containerId);
    const nodeArray = [];
    
    if (isMobile || window.innerWidth <= 1024) {
        // Mobile: Use grid layout
        skills.forEach(skill => {
            const node = document.createElement('div');
            node.className = 'skill-node';
            node.textContent = skill.name;
            container.appendChild(node);
            
            // Add click event for glass shard effect
            node.addEventListener('click', (e) => {
                node.classList.toggle('constellation-active');
                
                // Create glass shard effect
                const rect = node.getBoundingClientRect();
                createGlassShards(rect.left + rect.width / 2, rect.top + rect.height / 2, 8);
                
                // Create pulse effect
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    connectionParticles.push({
                        x: rect.left + rect.width / 2,
                        y: rect.top + rect.height / 2,
                        vx: Math.cos(angle) * 3,
                        vy: Math.sin(angle) * 3,
                        radius: 2,
                        opacity: 0.8,
                        color: containerId.includes('analyst') ? '#58a6ff' : '#67e97b'
                    });
                }
            });
            
            const nodeData = { element: node, side: containerId.split('-')[0], skill: skill };
            nodeArray.push(nodeData);
            allNodes.push(nodeData);
        });
    } else {
        // Desktop: Use absolute positioning
        let skillsToShow = skills;
        
        skillsToShow.forEach(skill => {
            const node = document.createElement('div');
            node.className = 'skill-node';
            node.textContent = skill.name;
            
            let x, y, tooClose;
            do {
                tooClose = false;
                x = 10 + Math.random() * 80;
                y = 15 + Math.random() * 70;
                
                for (const existingNode of nodeArray) {
                    const dist = Math.sqrt(Math.pow(existingNode.x - x, 2) + Math.pow(existingNode.y - y, 2));
                    if (dist < 20) {
                        tooClose = true;
                        break;
                    }
                }
            } while (tooClose);
            
            node.style.left = `${x}%`;
            node.style.top = `${y}%`;
            container.appendChild(node);
            
            // Keep constellation click event
            node.addEventListener('click', () => {
                node.classList.toggle('constellation-active');
                // Create burst effect
                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2;
                    const rect = node.getBoundingClientRect();
                    connectionParticles.push({
                        x: rect.left + rect.width / 2,
                        y: rect.top + rect.height / 2,
                        vx: Math.cos(angle) * 5,
                        vy: Math.sin(angle) * 5,
                        radius: 3,
                        opacity: 1,
                        color: containerId.includes('analyst') ? '#58a6ff' : '#67e97b'
                    });
                }
            });
            
            const nodeData = { element: node, x, y, side: containerId.split('-')[0], skill: skill };
            nodeArray.push(nodeData);
            allNodes.push(nodeData);
        });
    }
}

// Initialize project cards
function initializeProjectCards() {
    const cards = document.querySelectorAll('.project-card');
    cards.forEach(card => {
        const cardData = {
            element: card,
            type: 'project-card',
            side: 'project'
        };
        projectCards.push(cardData);
        allNodes.push(cardData);
    });
}

// Update connection particles
function updateConnectionParticles() {
    connectionParticles = connectionParticles.filter(particle => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.vx *= 0.98;
        particle.vy *= 0.98;
        particle.opacity *= 0.95;
        particle.radius *= 0.98;
        
        ctx.save();
        ctx.globalAlpha = particle.opacity;
        ctx.fillStyle = particle.color;
        ctx.shadowBlur = 8;
        ctx.shadowColor = particle.color;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        return particle.opacity > 0.01;
    });
}

// Main animation loop
function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    animationTime += 0.016;
    
    // Create occasional shooting stars (less frequent on mobile)
    if (!isMobile || Math.random() < 0.0005) {
        createShootingStar();
    }
    updateShootingStars();
    
    // Create mouse trail (fewer particles on mobile)
    if (mouse.x && mouse.y && (!isMobile || mouseTrails.length < 10)) {
        createMouseTrail();
    }
    updateMouseTrails();
    
    // Render everything
    renderEnhancedStars();
    renderEnhancedConnections();
    updateConnectionParticles();
    updateGlassShards();
    
    requestAnimationFrame(animate);
}

// Mobile and touch detection
function detectMobile() {
    isMobile = window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    return isMobile;
}

// Touch event handlers
function handleTouchStart(e) {
    if (e.touches && e.touches.length > 0) {
        mouse.x = e.touches[0].clientX;
        mouse.y = e.touches[0].clientY;
    }
}

function handleTouchMove(e) {
    if (e.touches && e.touches.length > 0) {
        mouse.x = e.touches[0].clientX;
        mouse.y = e.touches[0].clientY;
        // Don't prevent default on mobile to allow scrolling
    }
}

function handleTouchEnd(e) {
    setTimeout(() => {
        mouse.x = null;
        mouse.y = null;
    }, 300);
}

// Add section header click handlers for mobile collapse
function addMobileCollapsibility() {
    if (window.innerWidth <= 1024) {
        const headers = document.querySelectorAll('.mindset-side h2');
        headers.forEach(header => {
            header.style.cursor = 'pointer';
            header.addEventListener('click', function() {
                const skillsCloud = this.nextElementSibling;
                if (skillsCloud.classList.contains('expanded')) {
                    skillsCloud.classList.remove('expanded');
                    skillsCloud.classList.add('collapsed');
                } else {
                    skillsCloud.classList.remove('collapsed');
                    skillsCloud.classList.add('expanded');
                }
            });
        });
    }
}

// Initialization
function init() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    detectMobile();
    createEnhancedStarField();
    createSkillNodes('analyst-skills', analystSkills);
    createSkillNodes('developer-skills', developerSkills);
    initializeProjectCards();
    addMobileCollapsibility();
    
    // Mouse events for desktop
    window.addEventListener('mousemove', e => {
        if (!isTouch) {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        }
    });
    
    // Touch events for mobile
    if (isTouch) {
        canvas.addEventListener('touchstart', handleTouchStart, { passive: true });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: true });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: true });
    }
    
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const wasMobile = isMobile;
        detectMobile();
        
        // If switching between mobile and desktop, rebuild the interface
        if (wasMobile !== isMobile) {
            // Clear existing nodes
            document.getElementById('analyst-skills').innerHTML = '';
            document.getElementById('developer-skills').innerHTML = '';
            allNodes.length = 0;
            projectCards.length = 0;
            
            // Rebuild
            createSkillNodes('analyst-skills', analystSkills);
            createSkillNodes('developer-skills', developerSkills);
            initializeProjectCards();
            addMobileCollapsibility();
        }
        
        createEnhancedStarField();
    });
    
    // Start animation
    animate();
}

init();
});
</script>

</body>
</html>